import os
import json
import base64
import zipfile
import tempfile
import shutil
from pathlib import Path
from langchain.prompts import PromptTemplate
from langchain_core.runnables import RunnableSequence
from langchain.tools import Tool
from langchain.agents import initialize_agent
from langchain_openai import AzureChatOpenAI

# === OpenAI Azure Client (decrypt credentials, similar to yours) ===
import logging
from base64 import b64decode
from Crypto.Cipher import AES
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()

def unpad(data):
    return data[:-data[-1]]
def decrypt(data, key):
    cipher = AES.new(b64decode(key), AES.MODE_ECB)
    decrypted_data = cipher.decrypt(b64decode(data))
    return unpad(decrypted_data).decode()

def get_openai_client(model_instance_name=None):
    try:
        aes_key = os.environ['AES_KEY']
        encrypted_base = os.environ['ENCRYPTED_API_BASE']
        encrypted_key = os.environ['ENCRYPTED_API_KEY']
        api_version = os.environ['AZURE_API_VERSION']
        deployment = model_instance_name or os.environ['DEPLOYMENT_NAME']
        base = decrypt(encrypted_base, aes_key)
        key = decrypt(encrypted_key, aes_key)
        if not base.endswith('/'):
            base += '/'
        return AzureChatOpenAI(
            deployment_name=deployment,
            openai_api_base=base,
            openai_api_key=key,
            openai_api_version=api_version
        )
    except Exception as e:
        logger.error("OpenAI init failed: %s", e)
        raise

# === Your unchanged tools ===
java_files = []
parsed_code_info = []
junit_suggestions = []

def list_java_files(directory: str) -> str:
    global java_files
    java_files = list(Path(directory).rglob("*.java"))
    return f"[FOUND] {len(java_files)} Java files."

def extract_code_info(_: str) -> str:
    global java_files, parsed_code_info
    if not java_files:
        return "[SKIP] No Java files to parse."
    parsed_code_info.clear()
    prompt = PromptTemplate(input_variables=["source"],
        template="""...""" )
    chain = prompt | get_openai_client()
    for fp in java_files:
        try:
            content = fp.read_text(encoding="utf-8")
            result = chain.invoke({"source": content})
            j = json.loads(result.content.strip())
            if "class_name" in j:
                parsed_code_info.append(j)
        except Exception as e:
            logger.error("Parsing %s failed: %s", fp.name, e)
    return f"[SUCCESS] Parsed {len(parsed_code_info)} files."

def generate_junit_tests(_: str) -> str:
    global parsed_code_info, junit_suggestions
    junit_suggestions.clear()
    if not parsed_code_info:
        return "[SKIP] No parsed classes."
    prompt = PromptTemplate(input_variables=["class_name","class_type","package_path","methods"],
        template="""...""" )
    chain = prompt | get_openai_client()
    for item in parsed_code_info:
        try:
            result = chain.invoke({
                "class_name": item["class_name"],
                "class_type": item["class_type"],
                "package_path": item["package_path"],
                "methods": "\n".join(item["methods"])
            })
            junit_suggestions.append({
                "file_name": f"{item['class_name']}Test.java",
                "package_path": item["package_path"],
                "code": result.content.strip()
            })
        except Exception as e:
            logger.error("Generate test for %s failed: %s", item.get("class_name"), e)
    return f"[SUCCESS] Generated {len(junit_suggestions)} test classes."

def save_and_collect(_: str) -> str:
    global junit_suggestions
    results = []
    for tst in junit_suggestions:
        results.append({
            "file_name": tst["file_name"],
            "package_path": tst["package_path"],
            "code": tst["code"]
        })
    return json.dumps(results)

tools = [
    Tool(name="ListJavaFiles", func=list_java_files, description="..."),
    Tool(name="ExtractCodeInfo", func=extract_code_info, description="..."),
    Tool(name="GenerateJUnitTests", func=generate_junit_tests, description="..."),
    Tool(name="SaveJUnitTests", func=save_and_collect, description="...")
]

pipeline_text = """
ListJavaFiles
Then ExtractCodeInfo
Then GenerateJUnitTests
Finally SaveJUnitTests
"""

def lambda_handler(event, context):
    # decode body
    if event.get("isBase64Encoded"):
        raw = base64.b64decode(event["body"])
    else:
        raw = event["body"].encode('latin1')
    # write to temp zip
    tmp = tempfile.mkdtemp()
    zip_path = os.path.join(tmp, "upload.zip")
    with open(zip_path, "wb") as zz:
        zz.write(raw)
    # unzip
    extract_dir = os.path.join(tmp, "project")
    os.makedirs(extract_dir, exist_ok=True)
    with zipfile.ZipFile(zip_path, 'r') as zf:
        zf.extractall(extract_dir)
    # run pipeline
    os.chdir(extract_dir)
    agent = initialize_agent(
        tools=tools, llm=get_openai_client(), agent="zero-shot-react-description", verbose=False
    )
    result = agent.run(pipeline_text)
    # collect produced JSON result from Save tool
    response_items = json.loads(result)
    shutil.rmtree(tmp)
    return {
        "statusCode": 200,
        "isBase64Encoded": False,
        "headers": {"Content-Type": "application/json"},
        "body": json.dumps({
            "status": "success",
            "tests": response_items
        })
    }
