import os
import logging
import json
import re
from base64 import b64decode
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from langchain_community.chat_models import AzureChatOpenAI
from langchain.schema import HumanMessage
import zipfile
import xml.etree.ElementTree as ET
import tempfile

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()

# AES Decryption
def decrypt(data, key):
    cipher = AES.new(b64decode(key), AES.MODE_ECB)
    decrypted_data = cipher.decrypt(b64decode(data))
    decrypted_data = unpad(decrypted_data, AES.block_size)
    return decrypted_data.decode()

# Initialize Azure OpenAI Client
def get_openai_client(model_instance_name):
    aes_key_base64 = os.environ['AES_KEY']
    encrypted_api_base = os.environ['ENCRYPTED_API_BASE']
    encrypted_api_key = os.environ['ENCRYPTED_API_KEY']
    api_version = os.environ['AZURE_API_VERSION']

    decrypted_api_base = decrypt(encrypted_api_base, aes_key_base64)
    decrypted_api_key = decrypt(encrypted_api_key, aes_key_base64)

    if not decrypted_api_base.endswith('/'):
        decrypted_api_base += '/'

    return AzureChatOpenAI(
        deployment_name=model_instance_name,
        openai_api_base=decrypted_api_base,
        openai_api_key=decrypted_api_key,
        openai_api_version=api_version,
        temperature=0.4,
        max_tokens=4096
    )

# Extract text from DOCX
def extract_text_from_docx(docx_path):
    try:
        with zipfile.ZipFile(docx_path) as docx_zip:
            with docx_zip.open('word/document.xml') as document_xml_file:
                tree = ET.parse(document_xml_file)
                root = tree.getroot()
                namespaces = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
                paragraphs = []
                for paragraph in root.findall('.//w:p', namespaces):
                    texts = [node.text for node in paragraph.findall('.//w:t', namespaces) if node.text]
                    if texts:
                        paragraphs.append(''.join(texts))
                return '\n'.join(paragraphs)
    except Exception as e:
        logger.error(f"Failed to extract text from docx: {e}")
        return ""

# Build Dynamic Prompt
def build_prompt(endpoint_name, request_payload, response_payload, fields_map):
    prompt = f"""
1. Create a RAML specification for the API: {endpoint_name}, based on the table provided in the uploaded file.
2. The request will be in {request_payload} format and the response will be in {response_payload} format.

Instructions for RAML generation:
- Generate modular RAML with metadata, resources, types, query/URI parameters, security schemes, and supported MIME types.
- Create separate files for request/response examples and reference them in the main RAML.
- Build data type fragments and examples from the extracted table content.
- Follow the field mappings below while interpreting the table:

    - Fields: {fields_map.get('apiFields', '')}
    - Types: {fields_map.get('apiFieldType', '')}
    - Required: {fields_map.get('apiRequired', '')}
    - Nullable: {fields_map.get('apiNullable', '')}
    - Example: {fields_map.get('apiExample', '')}
    - Pattern: {fields_map.get('apiPattern', '')}

Use the structure and field data from the uploaded file to define request/response body, validations, and reusable components.
"""
    return prompt

# Lambda Entry
def lambda_handler(event, context):
    try:
        headers = event.get("headers", {}) or {}
        model_instance = headers.get("model_instance_name", "")
        count = int(headers.get("count", "1"))

        query = event.get("queryStringParameters", {}) or {}

        # Dynamic query parameters
        endpoint_name = query.get("endpointName", "")
        request_payload = query.get("requestPayload", "")
        response_payload = query.get("responsePayload", "")
        prompt_override = query.get("prompt")

        fields_map = {
            'apiFields': query.get("apiFields", ""),
            'apiFieldType': query.get("apiFieldType", ""),
            'apiRequired': query.get("apiRequired", ""),
            'apiNullable': query.get("apiNullable", ""),
            'apiExample': query.get("apiExample", ""),
            'apiPattern': query.get("apiPattern", "")
        }

        # Decode uploaded DOCX content
        body_b64 = event.get("body", "")
        if not body_b64:
            raise ValueError("Missing file content in body")

        body = b64decode(body_b64)
        with tempfile.NamedTemporaryFile(delete=False, suffix=".docx") as temp_file:
            temp_file.write(body)
            temp_file_path = temp_file.name

        extracted_text = extract_text_from_docx(temp_file_path)

        default_instruction = """
You are an expert in RAML (RESTful API Modeling Language) for designing and documenting RESTful APIs.
Your expertise allows you to create structured, human-readable RAML with Metadata, Types, Resources, Parameters, Examples, Security, and Fragments.
Follow best practices from https://raml.org/developers/raml-100-tutorial and modularize your output using includes and fragments.
"""

        full_prompt = (prompt_override or default_instruction) + "\n" + build_prompt(
            endpoint_name, request_payload, response_payload, fields_map
        ) + "\n\nHere is the extracted content from the file:\n" + extracted_text

        client = get_openai_client(model_instance)

        # Call Azure OpenAI
        response = client.invoke([
            HumanMessage(content=full_prompt),
            HumanMessage(content="Generate the RAML as described.")
        ])

        final_result = response.content.strip()

        return {
            "statusCode": 200,
            "headers": {"Content-Type": "application/json"},
            "body": json.dumps({"raml_spec": final_result})
        }

    except Exception as e:
        logger.error(f"Error: {e}")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)})
        }
