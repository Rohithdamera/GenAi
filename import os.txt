what is the misatake here



import os
import json
import re
import shutil
from pathlib import Path
from typing import List, Dict
import gradio as gr

from langchain.prompts import PromptTemplate
from langchain_openai import AzureChatOpenAI
from langchain.tools import Tool
from langchain.callbacks import get_openai_callback

# === Azure OpenAI Client ===
def get_openai_client():
    return AzureChatOpenAI(
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        deployment_name="gpt-4_complex_conversions",
        openai_api_key="", 
        openai_api_version="2024-08-01-preview",
        openai_api_type="azure",
        temperature=0.3,
        max_tokens=2000,
    )

llm = get_openai_client()

# === Tool 1: Identify Project Name & Path ===
def extract_project_details(user_input: str) -> Dict:
    """
    Extracts the new project name and reference project path from user input.
    Example: "generate a java project with aws_connector takes this path as a reference C:\Users\rdamera\Downloads\ddddd"
    """
    name_match = re.search(r"project with ([\w\-]+)", user_input, re.IGNORECASE)
    path_match = re.search(r"([A-Za-z]:[\\/\w\-. ]+)", user_input)

    if not name_match or not path_match:
        raise ValueError("Could not extract project name or path. Please provide both.")

    return {
        "new_name": name_match.group(1).strip(),
        "ref_path": Path(path_match.group(1).strip())
    }

# === Tool 2: Detect Existing Project Identifier ===
def detect_old_identifier(ref_path: Path) -> str:
    """
    Scans Java source to guess the old project identifier (e.g. 'salesforce_connector').
    Uses LLM to ensure accuracy.
    """
    java_files = list(ref_path.rglob("*.java"))
    if not java_files:
        raise FileNotFoundError("No Java files found in reference project.")

    sample_file = java_files[0].read_text(encoding="utf-8")

    prompt = PromptTemplate(
        input_variables=["code"],
        template="""
Identify the project/module name or main identifier used in the following Java codebase snippet.
This is typically found in package names, folder names, or class names.

Java snippet:
{code}

Return ONLY the identifier string (e.g., salesforce_connector). No explanation.
"""
    )
    chain = prompt | llm
    response = chain.invoke({"code": sample_file})
    return response.content.strip()

# === Tool 3: Clone and Replace Identifiers ===
def clone_and_replace(ref_path: Path, new_name: str, old_identifier: str) -> Path:
    """
    Copies the reference project into a new folder and replaces occurrences of old_identifier with new_name.
    """
    parent_dir = ref_path.parent
    new_project_path = parent_dir / new_name

    if new_project_path.exists():
        shutil.rmtree(new_project_path)
    shutil.copytree(ref_path, new_project_path)

    # Walk through all files and folders
    for root, dirs, files in os.walk(new_project_path, topdown=False):
        # Replace in filenames
        for filename in files:
            file_path = Path(root) / filename
            new_file_path = Path(root) / filename.replace(old_identifier, new_name)
            if file_path != new_file_path:
                file_path.rename(new_file_path)
                file_path = new_file_path

            # Replace inside file contents
            if file_path.suffix in [".java", ".xml", ".properties", ".yml", ".gradle", ".md", ".txt"]:
                content = file_path.read_text(encoding="utf-8")
                updated = content.replace(old_identifier, new_name)
                file_path.write_text(updated, encoding="utf-8")

        # Replace in directory names
        for d in dirs:
            if old_identifier in d:
                old_dir = Path(root) / d
                new_dir = Path(root) / d.replace(old_identifier, new_name)
                old_dir.rename(new_dir)

    return new_project_path

# === Tool 4: List Java Files ===
def list_java_files(path: str) -> List[Path]:
    base_path = Path(path)
    if not base_path.exists():
        raise FileNotFoundError(f"Path not found: {path}")
    return list(base_path.rglob("*.java"))

# === Tool 5: Extract Code Info ===
def extract_code_info(java_paths: List[Path]) -> List[Dict]:
    prompt = PromptTemplate(
        input_variables=["source"],
        template="""
Return ONLY compact JSON describing this Java class with these keys:
- class_name
- class_type (must be exactly: "Controller", "Service", "Repository", "Config", "Entity", "DTO", "Main")
- package_path
- methods: list of all public method names
- uses_repository: true/false
If class_type == "Entity", also include:
  "entity_fields": list of {{"name": fieldName, "type": fieldType}}

Rules:
- Do not explain.
- Always valid JSON.

Java Source:
{source}
"""
    )
    chain = prompt | llm
    parsed = []
    for file_path in java_paths:
        try:
            source = file_path.read_text(encoding="utf-8")
            response = chain.invoke({"source": source})
            data = json.loads(response.content.strip())
            parsed.append(data)
        except Exception as e:
            print(f"[WARN] Failed to parse {file_path}: {e}")
    return parsed

# === Tool 6: Generate JUnit Tests (same as before) ===
def generate_junit_tests(parsed_info: List[Dict]) -> List[Dict]:
    ALLOWED_TYPES = {"Controller", "Service"}
    entity_map = {
        item["class_name"]: item.get("entity_fields", [])
        for item in parsed_info
        if item.get("class_type") == "Entity"
    }
    prompt = PromptTemplate(
        input_variables=[
            "class_name","class_type","package_path","methods","uses_repository","entity_map"
        ],
        template=""" ... (same as your current JUnit prompt) ... """
    )
    chain = prompt | llm
    test_classes = []
    for item in parsed_info:
        if item["class_type"] not in ALLOWED_TYPES:
            continue
        try:
            result = chain.invoke({
                "class_name": item["class_name"],
                "class_type": item["class_type"],
                "package_path": item["package_path"],
                "methods": "\n".join(item["methods"]),
                "uses_repository": str(item.get("uses_repository", False)).lower(),
                "entity_map": json.dumps(entity_map, indent=2),
            })
            test_classes.append({
                "file_name": f"{item['class_name']}Test.java",
                "package_path": item["package_path"],
                "code": result.content.strip(),
            })
        except Exception as e:
            print(f"[WARN] Could not generate test for {item['class_name']}: {e}")
    return test_classes

# === Tool 7: Save Tests ===
def save_and_print_tests(junit_tests: List[Dict]) -> str:
    output = ""
    for test in junit_tests:
        folder = Path("generated_tests") / test["package_path"].replace(".", "/")
        folder.mkdir(parents=True, exist_ok=True)
        file_path = folder / test["file_name"]
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(test["code"])
        output += f"\n===== {test['file_name']} =====\n{test['code']}\n"
    return output.strip()

# === Register Tools ===
tools = [
    Tool(name="ExtractProjectDetails", func=extract_project_details, description="Extracts new project name and reference path."),
    Tool(name="DetectOldIdentifier", func=detect_old_identifier, description="Detects old project identifier."),
    Tool(name="CloneAndReplace", func=clone_and_replace, description="Clones project and replaces identifiers."),
    Tool(name="ListJavaFiles", func=list_java_files, description="Lists all Java files."),
    Tool(name="ExtractCodeInfo", func=extract_code_info, description="Parses each Java file."),
    Tool(name="GenerateJUnitTests", func=generate_junit_tests, description="Generates JUnit 5 test classes."),
    Tool(name="SaveJUnitTests", func=save_and_print_tests, description="Saves tests to disk and prints them."),
]

# === Orchestration ===
def process_java_project(user_input: str, history):
    try:
        details = tools[0].func(user_input)
        old_identifier = tools[1].func(details["ref_path"])
        new_project_path = tools[2].func(details["ref_path"], details["new_name"], old_identifier)

        java_files = tools[3].func(str(new_project_path))
        parsed_info = tools[4].func(java_files)
        junit_tests = tools[5].func(parsed_info)
        output_code = tools[6].func(junit_tests)

        return f"[SUCCESS] New project created at {new_project_path}\n\n{output_code}"
    except Exception as e:
        return f"[ERROR] {str(e)}"

# === Gradio UI ===
chatbot_ui = gr.ChatInterface(
    fn=process_java_project,
    title="Java Project Generator & JUnit Creator",
    description="Generate a new Java project from a reference path with replaced identifiers, plus JUnit tests.",
    theme="default",
)

if __name__ == "__main__":
    chatbot_ui.launch()
