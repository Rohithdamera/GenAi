import gradio as gr
import boto3
import re
from langchain_openai import AzureChatOpenAI

# --- AWS S3 Configuration ---
s3 = boto3.client(
    "s3",
    aws_access_key_id="AKIA6ODVATHCN52UKSRUO",
    aws_secret_access_key="N3+vw0XS4ZcdzqM0Zk6qflR7UbNy0ztQgdwWoiuEO",
    region_name="us-east-1"
)

S3_BUCKET = "osif-files"
S3_KEY = "OSIF_Dependency_req.txt"

# --- Azure OpenAI Client ---
def get_openai_client():
    return AzureChatOpenAI(
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        deployment_name="gpt-4_complex_conversions",
        openai_api_key="",  # <-- put your real API key
        openai_api_version="2025-01-01-preview",
        openai_api_type="azure",
        temperature=0.3,
        max_tokens=2000,
    )

llm = get_openai_client()


# --- Load file from S3 ---
def load_s3_file():
    obj = s3.get_object(Bucket=S3_BUCKET, Key=S3_KEY)
    return obj["Body"].read().decode("utf-8")


# --- Identify connector name using AI ---
def identify_connector(query, content):
    """
    Ask Azure OpenAI to map the query to one of the available connectors in the file.
    """
    # Extract all available connector titles from file
    titles = re.findall(r"Title\s*:\s*(.+)", content, flags=re.IGNORECASE)
    connector_list = "\n".join([t.strip() for t in titles])

    prompt = f"""
You are given a list of connector titles from a file:
{connector_list}

User asked: "{query}"

Your task:
- Identify which connector title best matches the user's request.
- Only return the exact connector title string from the list above.
- If nothing matches, return "NOT_FOUND".
"""

    response = llm.invoke(prompt)
    connector = response.content.strip()
    return connector


# --- Extract the full connector block ---
def extract_block(content, connector_title):
    """
    Extracts the full YAML-like block from file content starting with 'Title : connector_title'
    until the next 'Title :' or end of file.
    """
    if connector_title == "NOT_FOUND":
        return "Could not identify connector from your question."

    # Split into blocks by Title
    blocks = re.split(r"(?=Title\s*:)", content, flags=re.IGNORECASE)
    for block in blocks:
        if not block.strip():
            continue
        if re.search(rf"Title\s*:\s*{re.escape(connector_title)}", block, flags=re.IGNORECASE):
            return block.strip()

    return f"Connector '{connector_title}' not found in file."


# --- Chatbot handler ---
def chatbot_response(message, history):
    try:
        content = load_s3_file()
        connector_title = identify_connector(message, content)
        result = extract_block(content, connector_title)
        return result
    except Exception as e:
        return f"Error: {str(e)}"


# --- Gradio Chat UI ---
chatbot_ui = gr.ChatInterface(
    fn=chatbot_response,
    title="OSIF Connector Lookup",
    description="Ask about connector properties (e.g., 'give me sales force connector properties')",
    theme="default"
)

if __name__ == "__main__":
    chatbot_ui.launch(debug=False)


Now, when you ask:

give me sales-force-connector properties

the chatbot will pull the entire Salesforce connector block (with authUrl, username, password, client_id, etc.) from the .txt file in S3, instead of returning only the short stub.

Do you also want me to normalize indentation in the returned YAML block so itâ€™s always formatted cleanly for display?

