import os
import re
import yaml
import gradio as gr
import boto3
from typing import TypedDict, Optional, List, Tuple
from difflib import get_close_matches
from langchain_core.messages import HumanMessage, AIMessage
from langchain_openai import AzureChatOpenAI
from langchain_community.agent_toolkits.load_tools import load_tools
from langgraph.prebuilt import create_react_agent
from langgraph.graph import StateGraph, END
from langgraph.graph import MessagesState
 
# -------------------------
# AWS S3 Utility
# -------------------------
def fetch_s3_file_content(arn: str) -> str:
    print("Fetching S3 file content...")
    match = re.match(r"^arn:aws:s3:::(.+?)/(.*)$", arn)
    if not match:
        raise ValueError("Invalid S3 ARN format")
 
    bucket, key = match.groups()
 
    s3 = boto3.client("s3",
                      aws_access_key_id="AKIA6ODVATHCN52UKSR",
                      aws_secret_access_key="N3+vw0XS4ZcdzqM0Zk6qflR7UbNy0ztQgdwWoiu",
                      region_name="us-east-1")
 
    obj = s3.get_object(Bucket=bucket, Key=key)
    content = obj["Body"].read().decode("utf-8")
 
    if not content.strip():
        raise ValueError("S3 file is empty or unreadable.")
 
    print("S3 content fetched successfully.")
    return content
 
def get_connector_data_from_s3():
    S3_ARN = "arn:aws:s3:::osif-files/OSIF_Dependency_req.txt"
    try:
        file_content = fetch_s3_file_content(S3_ARN)
        parsed_yaml = yaml.safe_load(file_content)
        connectors = parsed_yaml.get("core", {}).get("connectors", {})
 
        # Build title-to-key mapping
        title_to_key = {}
        for key, value in connectors.items():
            title = value.get("title", key)  # fallback to key if no title
            title_to_key[title.lower()] = key
 
        print("Connectors found:", list(connectors.keys()))
        return connectors, file_content, title_to_key
    except Exception as e:
        print(f"Failed to load connector data: {e}")
        return {}, "", {}
 
# -------------------------
# LangChain + Graph Setup
# -------------------------
class State(TypedDict):
    messages: MessagesState
 
llm = AzureChatOpenAI(
    deployment_name="Fourth_Chatbot",
    azure_endpoint="https://testopenaiassets.openai.azure.com",
    openai_api_key="",
    openai_api_version="2024-08-01-preview"
)
 
tools = load_tools(["llm-math"], llm=llm)
agent_node = create_react_agent(llm, tools)
 
graph = StateGraph(State)
graph.add_node("react_agent", agent_node)
graph.set_entry_point("react_agent")
graph.add_edge("react_agent", END)
agent_executor = graph.compile()
 
# -------------------------
# Chatbot Handler
# -------------------------
def chat_with_agent(message: str, history: Optional[List[Tuple[str, str]]] = None) -> str:
    print("Received message:", message)
 
    if history is None:
        history = []
 
    connector_data, file_content, title_to_key = get_connector_data_from_s3()
    message_lower = message.lower()
 
    if "property" in message_lower or "configuration" in message_lower:
        all_possible_names = list(connector_data.keys()) + list(title_to_key.keys())
        matched_keys = get_close_matches(message_lower, all_possible_names, n=1, cutoff=0.4)
 
        if matched_keys:
            matched = matched_keys[0]
            connector_key = title_to_key.get(matched, matched)  # resolve title to key if needed
            print(f"Matched connector: {matched} â†’ key: {connector_key}")
 
            lines = file_content.splitlines()
            start_index = None
            for i, line in enumerate(lines):
                if re.match(rf"^{connector_key}:\s*$", line.strip()):
                    start_index = i
                    break
 
            if start_index is not None:
                block_lines = [lines[start_index]]
                base_indent = len(lines[start_index]) - len(lines[start_index].lstrip())
 
                for j in range(start_index + 1, len(lines)):
                    current_line = lines[j]
                    current_indent = len(current_line) - len(current_line.lstrip())
                    if current_line.strip() == "":
                        block_lines.append(current_line)
                    elif current_indent > base_indent:
                        block_lines.append(current_line)
                    else:
                        break
 
                exact_block = "\n".join(block_lines)
                response = f"**Exact configuration for `{connector_key}` connector:**\n```yaml\n{exact_block}\n```"
                return response
            else:
                return f"Connector `{connector_key}` found, but exact formatting could not be extracted."
 
        return "No matching connector found in the S3 file."
 
    # Fallback to LangChain agent for general queries
    messages = []
    for user_msg, bot_msg in history:
        messages.append(HumanMessage(content=user_msg))
        messages.append(AIMessage(content=bot_msg))
    messages.append(HumanMessage(content=message))
 
    result = agent_executor.invoke({"messages": messages}, verbose=True)
    return result["messages"][-1].content
 
# -------------------------
# Main Entry Point
# -------------------------
if __name__ == "__main__":
    print("Launching Gradio interface...")
    gr.Interface(
        fn=chat_with_agent,
        inputs="text",
        outputs="text",
        title="OSIF Agent Chat",
        description="Ask about connector configurations or general queries."
    ).launch()
 
