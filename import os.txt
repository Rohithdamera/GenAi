Ah I see what‚Äôs happening üëÄ

The error WinError 183 means we‚Äôre trying to rename a file/folder into a path that already exists.
That happened because we were renaming inside the copied project while the structure was already nested.

üëâ Your new idea is correct:

1. First copy the project exactly as-is from the reference path to the destination.


2. Then run AI/tools only for replacement ‚Üí detect all occurrences of the old project name in folder names, file names, and main/test class content.


3. Safely rename after the copy is complete, instead of renaming while copying.



Here‚Äôs the fully updated version (safe flow):

import os
import shutil
from pathlib import Path
import gradio as gr
import json
from langchain.prompts import PromptTemplate
from langchain_openai import AzureChatOpenAI


# === Azure OpenAI Client ===
def get_openai_client():
    return AzureChatOpenAI(
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        deployment_name="gpt-4_complex_conversions",
        openai_api_key="",   # üîë put your key
        openai_api_version="2024-08-01-preview",
        openai_api_type="azure",
        temperature=0.3,
        max_tokens=4000,
    )

llm = get_openai_client()


# === Extract user intent ===
def extract_user_intent(user_input: str) -> dict:
    prompt = PromptTemplate(
        input_variables=["user_input"],
        template="""
From the request, extract:
1. new_project_name (e.g., AWS_Connector, GCP_Connector)  
2. reference_path (absolute folder path)  

Return JSON only:
{{
  "new_project_name": "...",
  "reference_path": "..."
}}

User request:
{user_input}
"""
    )
    response = (prompt | llm).invoke({"user_input": user_input})
    return json.loads(response.content.strip())


# === Detect old project name from reference path ===
def detect_old_project_name(reference_path: str) -> str:
    prompt = PromptTemplate(
        input_variables=["path"],
        template="""
Given this reference path: {path}  
Identify the main reference project name (the folder name used as the root).  

Return only the name string.
"""
    )
    response = (prompt | llm).invoke({"path": reference_path})
    return response.content.strip()


# === AI decide what needs replacing ===
def ai_should_replace(old_name: str, new_name: str, file_path: str) -> dict:
    prompt = PromptTemplate(
        input_variables=["old_name", "new_name", "file_path"],
        template="""
We are refactoring a Java project.

Old name: {old_name}  
New name: {new_name}  
File path: {file_path}  

Rules:
- Replace old_name with new_name in folder names, package names, main/test class names.
- Other files (controllers, services, repos, configs) remain unchanged.
- Only main and test classes should have **content updated**.
- Return JSON only.

Format:
{{
  "rename": true/false,
  "new_name": "new-name-if-applicable",
  "update_content": true/false
}}
"""
    )
    response = (prompt | llm).invoke(
        {"old_name": old_name, "new_name": new_name, "file_path": file_path}
    )
    return json.loads(response.content.strip())


# === AI rewrite only main/test classes ===
def ai_rewrite_main(source: str, old_name: str, new_name: str) -> str:
    prompt = PromptTemplate(
        input_variables=["source", "old_name", "new_name"],
        template="""
Refactor only the main or test Application class.

- Old project name: {old_name}
- New project name: {new_name}
- Rename class accordingly (e.g., AWS_ConnectorApplication, AWS_ConnectorApplicationTests).
- Keep imports/annotations the same.
- Return only the updated file text.

File:
{source}
"""
    )
    response = (prompt | llm).invoke(
        {"source": source, "old_name": old_name, "new_name": new_name}
    )
    return response.content.strip()


# === Step: Generate new project ===
def generate_project(reference_path: str, old_name: str, new_name: str) -> str:
    ref_path = Path(reference_path)
    if not ref_path.exists():
        return f"[ERROR] Reference project not found: {reference_path}"

    # Copy project "as-is"
    target_base = Path("C:/Users/rdamera/Downloads/ddddd")
    target_path = target_base / new_name
    if target_path.exists():
        shutil.rmtree(target_path)

    shutil.copytree(ref_path, target_path)

    # Now perform replacements
    for file_path in list(target_path.rglob("*"))[::-1]:  
        # (reverse order to safely rename nested files first)

        decision = ai_should_replace(old_name, new_name, str(file_path))

        # === Rename folders/files ===
        if decision.get("rename", False):
            new_file_path = file_path.with_name(
                file_path.name.replace(old_name, new_name)
            )
            if not new_file_path.exists():  # prevent WinError 183
                file_path.rename(new_file_path)
                file_path = new_file_path

        # === Rewrite main/test classes ===
        if decision.get("update_content", False) and file_path.is_file():
            try:
                source = file_path.read_text(encoding="utf-8", errors="ignore")
                updated = ai_rewrite_main(source, old_name, new_name)
                file_path.write_text(updated, encoding="utf-8")
            except Exception as e:
                print(f"[WARN] Could not update {file_path}: {e}")

    return str(target_path)


# === Main Orchestration ===
def process_java_project(user_input: str, history):
    try:
        intent = extract_user_intent(user_input)
        ref_path = intent["reference_path"]
        new_name = intent["new_project_name"]

        old_name = detect_old_project_name(ref_path)
        new_path = generate_project(ref_path, old_name, new_name)

        return f"[SUCCESS] Project '{new_name}' created at {new_path}"

    except Exception as e:
        return f"[ERROR] {str(e)}"


# === Gradio UI ===
chatbot_ui = gr.ChatInterface(
    fn=process_java_project,
    title="AI Java Project Generator",
    description="Provide a new project name and reference path. AI will copy the project, then replace old project name with the new one in folder names and only main/test classes.",
    theme="default",
)

if __name__ == "__main__":
    chatbot_ui.launch()


---

‚úÖ Fixes applied:

1. Two-phase flow

Step 1: Copy reference project ‚Äúas-is‚Äù.

Step 2: Rename + rewrite after copy ‚Üí avoids duplicate .project rename errors.



2. Reverse traversal ([::-1])

Ensures deepest files/folders renamed first ‚Üí avoids conflicts with parent rename.



3. Safe check before rename

Skips renaming if target already exists (WinError 183 prevention).





---

Do you want me to also add AI detection of all package paths (com/example/.../old_name) ‚Üí so that they get updated automatically, or keep only folder/class renaming for now?

