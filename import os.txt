def invoke_react_agent_with_file(user_prompt: str, history, file_obj) -> str:
    """
    Prepare messages and invoke the ReAct agent. Wrap invocation with TokenTracker for usage.
    """
    messages = []
    if history is not None:
        for user_msg, bot_msg in history:
            messages.append(HumanMessage(content=user_msg))
            messages.append(AIMessage(content=bot_msg))

    file_content = ""
    if file_obj is not None:
        try:
            with open(file_obj.name, "r", encoding="utf-8", errors="ignore") as f:
                file_content = f.read()
        except Exception as e:
            file_content = f"[Error reading file: {e}]"

    if file_content:
        user_message = (
            f"User question:\n{user_prompt}\n\n"
            f"Attached file content:\n{file_content}\n"
        )
    else:
        user_message = user_prompt

    messages.append(HumanMessage(content=user_message))

    def _invoke():
        return react_agent.invoke(
            {"messages": messages},
            config={"callbacks": [ConsoleCallbackHandler()]}
        )

    response, usage = TokenTracker.run(_invoke)
    # response could be an LLM/agent response; try to return content if present
    try:
        return response.content.strip() + usage
    except Exception:
        # Fallback: str(response)
        return str(response) + usage

# ====================================================
# Unified Chatbot Function (merges both chat_with_agent and unified_chatbot logic)
# - Keeps code1's behavior intact, and calls ReAct / MySQL when input indicates.
# ====================================================
model_agent = ModelAgent()
junit_agent = JUnitAgent()
connector_agent = ConnectorAgent()
client_agent = ClientClassAgent()

# Keywords to detect logs and code-analysis requests
LOG_KEYWORDS = ["log", "logs", "error", "errors", "warn", "warning", "exception", "stacktrace", "traceback", "logfile"]
CODE_KEYWORDS = ["code", "function", "error in", "fix", "class", "python", "java", "file", "compile", "bug", "exception"]

def unified_chatbot(prompt, history, uploaded_files=None):
    """
    Note: uploaded_files may be:
      - None
      - a single file-like object
      - a list of file-like objects (when file_count='multiple' and user uploads multiple files)
    We map those to yaml_file / java_file to preserve existing code expectations.
    The function now also handles:
      - MySQL log fetching when AI detects log-related intent in the prompt.
      - ReAct agent-based code/file analysis when file is uploaded or code-related keywords are present.
    """
    lower_prompt = (prompt or "").lower()

    # Normalize uploaded_files into yaml_file / java_file variables expected by downstream logic
    yaml_file = None
    java_file = None
    single_file_for_react = None
    if uploaded_files is not None:
        uploaded_list = uploaded_files if isinstance(uploaded_files, list) else [uploaded_files]
        for f in uploaded_list:
            try:
                suffix = Path(f.name).suffix.lower()
            except Exception:
                continue
            if suffix in (".yml", ".yaml") and yaml_file is None:
                yaml_file = f
            elif suffix == ".java" and java_file is None:
                java_file = f
            # Keep first file for react/code analysis as well
            if single_file_for_react is None:
                single_file_for_react = f
            # If both found, break early
            if yaml_file is not None and java_file is not None:
                break

    # 1) Log detection & retrieval (AI-driven)
    if any(k in lower_prompt for k in LOG_KEYWORDS):
        # If the user included DB connection info in the prompt (not recommended in plaintext),
        # try to extract a simple where-clause or connection overrides (basic support).
        # For safety, do not parse secrets; just allow a where clause like "where message like '%NullPointer%'" if explicitly provided.
        where_clause = None
        limit = 100
        # simple extraction: look for "limit N"
        limit_match = re.search(r"limit\s+(\d{1,4})", prompt, re.IGNORECASE)
        if limit_match:
            try:
                limit = int(limit_match.group(1))
            except Exception:
                limit = 100

        # try to find a where clause in user's prompt after the word 'where' (basic and naive)
        where_match = re.search(r"where\s+(.+)", prompt, re.IGNORECASE)
        if where_match:
            raw = where_match.group(1).strip()
            # limit the length for safety
            where_clause = raw[:1000]

        try:
            logs = fetch_logs_from_mysql(limit=limit, where_clause=where_clause)
            # Format logs nicely for display
            if not logs:
                return "[INFO] No logs found."
            # If first element contains 'error' key, pass that message
            formatted = ""
            for row in logs:
                formatted += json.dumps(row, default=str) + "\n"
            return formatted
        except Exception as e:
            return f"[ERROR] Failed to fetch logs: {e}"

    # 2) Code / file analysis via ReAct agent (from code2) or JUnit flow in code1
    # If file uploaded or code keywords present => prefer ReAct agent
    if single_file_for_react is not None or any(k in lower_prompt for k in CODE_KEYWORDS):
        # If the user explicitly wants JUnit (preserve code1 behavior)
        if "junit" in lower_prompt:
            return junit_agent.run(prompt)

        # Prefer ReAct agent if user uploaded a file or asked about code — keep original code1 flows for specific cases
        try:
            # If the user asked specifically about model generation, keep code1 behavior
            if ("model" in lower_prompt or "model class" in lower_prompt) and yaml_file is not None:
                return model_agent.run(prompt, yaml_file)

            # If client class requested or java file uploaded -> preserve code1 behavior for client generation
            if "client class" in lower_prompt or java_file is not None:
                if java_file is None:
                    return "[ERROR] Please upload a Java file for client class generation."
                return client_agent.run(prompt, java_file)

            # Otherwise use the ReAct agent to analyze the file or answer code questions
            response = invoke_react_agent_with_file(prompt, history, single_file_for_react)
            return response
        except Exception as e:
            return f"[ERROR] Code analysis failed: {e}"

    # 3) Preserve code1 connector detection flow (salesforce, s3, sqs, etc.)
    if any(k in lower_prompt for k in ["salesforce", "sfdc", "sqs", "s3", "common api"]):
        return connector_agent.run(prompt)

    # 4) Preserve code1 mapping — fallback to model/java/junit detection
    if "junit" in lower_prompt:
        return junit_agent.run(prompt)

    if "model" in lower_prompt or "model class" in lower_prompt:
        if yaml_file is None:
            return "[ERROR] Please upload a YAML file for model class generation."
        return model_agent.run(prompt, yaml_file)

    if "client class" in lower_prompt or java_file is not None:
        if java_file is None:
            return "[ERROR] Please upload a Java file for client class generation."
        return client_agent.run(prompt, java_file)

    if any(k in lower_prompt for k in ["salesforce", "sfdc", "sqs", "s3", "common api"]):
        return connector_agent.run(prompt)

    # Fallbacks
    if yaml_file is not None:
        return model_agent.run(prompt, yaml_file)
    elif java_file is not None:
        return client_agent.run(prompt, java_file)
    elif re.search(r"([A-Za-z]:[\\/\w\-. ]+)", prompt):
        return junit_agent.run(prompt)
    else:
        return "[ERROR] Please upload a YAML file with prompt for models, a Java file for client class, provide a valid file path for JUnit generation, or ask about logs/errors to fetch logs."

# ====================================================
# Gradio Chat Interface (unchanged UI)
# ====================================================
chatbot_ui = gr.ChatInterface(
    fn=unified_chatbot,
    title="OSIF_Co-Developer",
    description=(
        "Options:\n"
        "1. Upload a YAML file and enter a prompt like: `generate model class from this config`\n"
        "2. Provide a Windows file path like: `C:\\Users\\project\\src` to generate JUnit tests.\n"
        "3. Ask connector questions: e.g., `give connector properties of (salesforce, SQS, s3, CrossAccountSQS)`\n"
        "4. Upload a Java file and enter a prompt like: `create client class`"
    ),
    additional_inputs=[
        # Single upload box for both YAML and Java files. Allows multiple files but shows only one box in browser.
        gr.File(label="Upload File (YAML or Java)", file_types=[".yaml", ".yml", ".java"], file_count="multiple"),
    ],
    theme="default"
)

if __name__ == "__main__":
    print("Starting Unified Generator...")
    chatbot_ui.launch()
