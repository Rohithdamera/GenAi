update the below code , according to my requirements , if i ask question like (generate java project name as AWS_Connector by taking this path as a reference C:\Users\rdamera\Downloads\osif-java-cg-candidate) it need to generate the entire java project using reference path to generate the project the generated need to be stored in this path("C:/Users/rdamera/Downloads/ddddd"), do what ever changes need to change just change in the code , use less java code , keep more instruction and prompt , so the the generated java project structure remains to be same as the reference java project path, pom.xml , controllers , service etc everything need to be same , only change is to in the reference java  folders names, with actual provided name  for example if ask like  generate java project name as AWS_Connector it need to replace  reference project folder name (osif-java-cg-candidate) with the provided name by user  
ex(AWS_Connector)

reference project structure:-
1. C:\Users\rdamera\Downloads\osif-java-cg-candidate\osif-java-cg-candidate\osif-java-cg-candidate\src\main\java\com\example\osif_java_cg_candidate\main_method(OsifJavaCgCandidateApplication)

2. 1. C:\Users\rdamera\Downloads\osif-java-cg-candidate\osif-java-cg-candidate\osif-java-cg-candidate\src\main\test\com\example\osif_java_cg_candidate\main_method(OsifJavaCgCandidateApplicationTests)

expected project structure:
1.C:\Users\rdamera\Downloads\AWS_Connector\AWS_Connector\AWS_Connector\src\main\java\com\example\AWS_Connector\aws_connectorApplication_main

2.C:\Users\rdamera\Downloads\AWS_Connector\AWS_Connector\AWS_Connector\src\test\java\com\example\AWS_Connector\aws_connectorApplication_mainTests



the project structure will get changed for every project, so it need to identity reference folder names and its sub folders names and need to replace with user provided names where it need to declare , use tools if possible ,dont hard code anything , based on instruction, and prompt it need to generate the names based on user provided names like  ( AWS_Connector or gcp_connector), use tools if possible to identify  were ever project folders names to be replaced with user provided name, also dont generate the code inside of any folder, like controllers, repo etc , only main method need to be generated and main method name need to be replace with user provided name 



dont follow below approach 


    # Write main class
    main_dir = target_path / "src" / "main" / "java" / "com" / "example" / new_project_name
    main_dir.mkdir(parents=True, exist_ok=True)
    (main_dir / f"{new_project_name}Application.java").write_text(code["main_class"], encoding="utf-8")

    # Write test class
    test_dir = target_path / "src" / "test" / "java" / "com" / "example" / new_project_name
    test_dir.mkdir(parents=True, exist_ok=True)
    (test_dir / f"{new_project_name}ApplicationTests.java").write_text(code["test_class"], encoding="utf-8")

    return str(target_path), 


AI only need to decide what to change to generate accurate java project , make this entire code as a agent based 




code:-



import os
import shutil
from pathlib import Path
import gradio as gr
import json
from langchain.prompts import PromptTemplate
from langchain_openai import AzureChatOpenAI


# === Azure OpenAI Client ===
def get_openai_client():
    return AzureChatOpenAI(
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        deployment_name="gpt-4_complex_conversions",
        openai_api_key="",
        openai_api_version="2024-08-01-preview",
        openai_api_type="azure",
        temperature=0.3,
        max_tokens=4000,
    )


llm = get_openai_client()


# === Step 1: Extract user intent ===
def extract_user_intent(user_input: str) -> dict:
    prompt = PromptTemplate(
        input_variables=["user_input"],
        template="""
From the following request, extract two things:

1. new_project_name → the new project name (e.g., AWS_Connector, GCP_Connector)  
2. reference_path → the given reference project path  

Return only valid JSON:
{{
  "new_project_name": "...",
  "reference_path": "..."
}}

User request:
{user_input}
"""
    )
    response = (prompt | llm).invoke({"user_input": user_input})
    return json.loads(response.content.strip())


# === Step 2: Detect old project name ===
def detect_old_project_name(reference_path: str) -> str:
    prompt = PromptTemplate(
        input_variables=["path"],
        template="""
You are given a reference project folder path: {path}.

From this path, identify the project name (the last folder name).  
Return only the project name, nothing else.
"""
    )
    response = (prompt | llm).invoke({"path": reference_path})
    return response.content.strip()


# === Step 3: AI rewrite file content ===
def ai_rewrite_file(source: str, old_name: str, new_name: str) -> str:
    prompt = PromptTemplate(
        input_variables=["source", "old_name", "new_name"],
        template="""
You are refactoring a Java project.

Rules:
- The old project name is {old_name}.
- Replace it consistently with {new_name}.
- This includes class names, package names, imports, configs, tests, comments.
- Keep structure, formatting, and other logic intact.
- Do not drop any content.
- Only output the updated file text.

File content:
{source}
"""
    )
    response = (prompt | llm).invoke(
        {"source": source, "old_name": old_name, "new_name": new_name}
    )
    return response.content.strip()


# === Step 4: Rewrite full project ===
def rewrite_project(reference_path: str, old_project_name: str, new_project_name: str) -> str:
    ref_path = Path(reference_path)
    if not ref_path.exists():
        return f"[ERROR] Reference project not found: {reference_path}"

    target_base = Path("C:/Users/rdamera/Downloads/ddddd")
    target_path = target_base / new_project_name
    if target_path.exists():
        shutil.rmtree(target_path)

    # Copy structure first
    shutil.copytree(ref_path, target_path)

    # Walk through and process
    for file_path in target_path.rglob("*"):
        # === 1. Rename folder names if they contain old project name ===
        if old_project_name in file_path.name:
            new_file_path = file_path.with_name(file_path.name.replace(old_project_name, new_project_name))
            file_path.rename(new_file_path)
            file_path = new_file_path

        # === 2. Rewrite file contents if text file ===
        if file_path.is_file() and file_path.suffix.lower() in [
            ".java", ".xml", ".yml", ".yaml", ".properties", ".json", ".md", ".txt"
        ]:
            try:
                source = file_path.read_text(encoding="utf-8", errors="ignore")
                updated = ai_rewrite_file(source, old_project_name, new_project_name)
                file_path.write_text(updated, encoding="utf-8")
            except Exception as e:
                print(f"[WARN] Skipping {file_path}: {e}")

    return str(target_path)


# === Main Orchestration ===
def process_java_project(user_input: str, history):
    try:
        # Extract what user asked
        intent = extract_user_intent(user_input)
        reference_path = intent["reference_path"]
        new_project_name = intent["new_project_name"]

        # Detect old project name
        old_project_name = detect_old_project_name(reference_path)

        # Rewrite everything
        new_path = rewrite_project(reference_path, old_project_name, new_project_name)
        return f"[SUCCESS] Project '{new_project_name}' created at {new_path}"

    except Exception as e:
        return f"[ERROR] {str(e)}"


# === Gradio UI ===
chatbot_ui = gr.ChatInterface(
    fn=process_java_project,
    title="AI Java Project Generator",
    description="Provide a reference project path and a new project name. AI will regenerate the full project with the same structure but with the new name everywhere.",
    theme="default",
)


if __name__ == "__main__":
    chatbot_ui.launch()
