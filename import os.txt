import os
import json
import time
import uuid
import asyncio
import nest_asyncio
import pandas as pd
import azure.functions as func
from langchain.chat_models import AzureChatOpenAI
from langchain.agents import Tool, initialize_agent
from langchain.agents.agent_types import AgentType
from mcp import ClientSession
from mcp.client.sse import sse_client
from base64 import b64decode
from Crypto.Cipher import AES

nest_asyncio.apply()

# ==== Session Handling ====
chat_sessions = {}
SESSION_TTL = 30 * 60  # 30 minutes

def create_session():
    conversation_id = str(uuid.uuid4())
    chat_sessions[conversation_id] = {
        "created_at": time.time(),
        "messages": []
    }
    return conversation_id

def add_message(conversation_id, role, content):
    if conversation_id in chat_sessions:
        chat_sessions[conversation_id]["messages"].append({
            "role": role,
            "content": content
        })

def get_history(conversation_id):
    return chat_sessions.get(conversation_id, {}).get("messages", [])

def cleanup_expired_sessions():
    current_time = time.time()
    expired_ids = [cid for cid, s in chat_sessions.items()
                   if current_time - s["created_at"] > SESSION_TTL]
    for cid in expired_ids:
        del chat_sessions[cid]

# ==== Decryption ====
def decrypt(encrypted_data, aes_key_base64):
    key = b64decode(aes_key_base64)
    data = b64decode(encrypted_data)
    iv = data[:16]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decrypted = cipher.decrypt(data[16:])
    pad_len = decrypted[-1]
    return decrypted[:-pad_len].decode('utf-8')

# ==== Azure OpenAI Setup ====
def get_openai_client(model_instance_name="Fourth_Chatbot"):
    aes_key_base64 = os.environ['AES_KEY']
    encrypted_api_base = os.environ['ENCRYPTED_API_BASE']
    encrypted_api_key = os.environ['ENCRYPTED_API_KEY']
    api_version = os.environ['AZURE_API_VERSION']

    decrypted_api_base = decrypt(encrypted_api_base, aes_key_base64)
    decrypted_api_key = decrypt(encrypted_api_key, aes_key_base64)

    if not decrypted_api_base.endswith('/'):
        decrypted_api_base += '/'

    return AzureChatOpenAI(
        deployment_name=model_instance_name,
        openai_api_base=decrypted_api_base,
        openai_api_key=decrypted_api_key,
        openai_api_version=api_version,
        temperature=0.4,
        max_tokens=4096
    )

# ==== Tool Setup ====
def sync_call_tool(tool_name: str, params: dict):
    async def call():
        sse_url = os.environ['MCP_SSE_URL']
        async with sse_client(url=sse_url) as streams:
            async with ClientSession(*streams) as session:
                await session.initialize()
                return await session.call_tool(tool_name, params)
    return asyncio.get_event_loop().run_until_complete(call())

def fetch_all_tools():
    async def fetch():
        sse_url = os.environ['MCP_SSE_URL']
        async with sse_client(url=sse_url) as streams:
            async with ClientSession(*streams) as session:
                await session.initialize()
                return await session.list_tools()
    return asyncio.get_event_loop().run_until_complete(fetch())

def get_tools():
    raw = fetch_all_tools()
    tools = []

    for t in getattr(raw, "tools", []):
        name = t.name
        required_fields = t.inputSchema.get("required", []) if t.inputSchema else []

        def make_func(tool_name=name, req=required_fields):
            def fn(input_str: str) -> str:
                try:
                    parsed = json.loads(input_str) if input_str else {}
                except:
                    parsed = {}
                for key in req:
                    parsed.setdefault(key, "")
                try:
                    result = sync_call_tool(tool_name, parsed)
                    return json.dumps(result, indent=2, default=str)
                except Exception as e:
                    return f"[ERROR] {tool_name}: {str(e)}"
            return fn

        tools.append(
            Tool(
                name=name,
                func=make_func(),
                description=f"{t.description or ''} Required fields: {required_fields}",
                return_direct=False,
            )
        )

    return tools

# ==== Output Rendering ====
def render_output_as_table(output_text: str):
    try:
        data = json.loads(output_text)
        if isinstance(data, list):
            df = pd.DataFrame(data)
        elif isinstance(data, dict):
            df = pd.DataFrame([data])
        else:
            return output_text
        return df.to_string(index=False)
    except Exception:
        return output_text

# ==== Prompt ====
CUSTOM_PREFIX = """
You are an intelligent support agent with access to multiple tools containing employee, project, and organizational data.

Your responsibilities:

- Always check all tools for relevant data before concluding that something is not found.
- If a tool returns partial information (like employee ID), use that to search in other tools.
- If names are misspelled or abbreviated (e.g., HYD for Hyderabad, benguluru for Bangalore), still attempt to resolve them using available data across all tools.
- Present the final answer in a table format only, with no emojis or markdown.
- Always attempt a multi-hop reasoning process until an accurate and complete answer is found.
- Never stop after a single failed attempt unless all tools are tried.
"""

# ==== Build Agent ====
def build_agent():
    tools = get_tools()
    llm = get_openai_client()
    return initialize_agent(
        tools=tools,
        llm=llm,
        agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
        verbose=True,
        max_iterations=10,
        handle_parsing_errors=True,
        agent_kwargs={"prefix": CUSTOM_PREFIX}
    )

# ==== Azure Function Entry Point ====
async def main(req: func.HttpRequest) -> func.HttpResponse:
    cleanup_expired_sessions()
    try:
        body = req.get_json()
        user_input = body.get("input")
        session_id = body.get("session_id") or create_session()

        if user_input.lower().strip() == "chat history":
            history = get_history(session_id)
            return func.HttpResponse(
                json.dumps({"session_id": session_id, "history": history}),
                mimetype="application/json"
            )

        agent = build_agent()
        result = agent.invoke({"input": user_input})
        final_output = result["output"]

        add_message(session_id, "user", user_input)
        add_message(session_id, "assistant", final_output)

        response_body = {
            "session_id": session_id,
            "answer": render_output_as_table(final_output)
        }

        return func.HttpResponse(json.dumps(response_body), mimetype="application/json")

    except Exception as e:
        return func.HttpResponse(
            json.dumps({"error": str(e)}),
            status_code=500,
            mimetype="application/json"
        )
