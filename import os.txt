import os
import re
from pathlib import Path

from langchain.chat_models import AzureChatOpenAI
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
from langchain.schema.output_parser import StrOutputParser
from langchain.schema.runnable import RunnableLambda, RunnablePassthrough, RunnableMap
from langchain.agents import initialize_agent, Tool
from langchain.memory import ConversationBufferMemory

# === Azure OpenAI client ===
def get_openai_client():
    return AzureChatOpenAI(
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        deployment_name="Fourth_Chatbot",
        openai_api_key="",  # Add key
        openai_api_version="2024-08-01-preview",
        openai_api_type="azure",
        temperature=0.7,
        max_tokens=2000,
        model_kwargs={"top_p": 0.9, "frequency_penalty": 0.2, "presence_penalty": 0.1}
    )

project_path = r"C:\Users\rdamera\Downloads\OrderManagement 1\OrderManagement"

# === AGENT 1: Java Class Parser ===
java_files = []
java_summary = ""

def list_java_files(_: str) -> str:
    global java_files
    java_files = [
        os.path.join(root, f)
        for root, _, files in os.walk(project_path)
        for f in files if f.endswith(".java")
    ]
    if not java_files:
        return "[STOP] No Java files found."
    return f"Found {len(java_files)} Java files."

def summarize_java_code(_: str) -> str:
    global java_summary, java_files

    if not java_files:
        return "[SKIP] No Java files to process."

    client = get_openai_client()
    java_prompt = PromptTemplate(
        input_variables=["java_content"],
        template="""
You are a Java code analysis expert.

Given this Java source file, extract:
- Class name
- Package path
- Type (Controller, Service, Repository, etc.)
- All public methods with signatures
- Internal method calls to other classes/methods
- List of dependencies (other classes it calls)

{java_content}

Return structured JSON format per file.
"""
    )

    chain = (
        RunnablePassthrough()
        | RunnableLambda(lambda paths: [Path(p).read_text(encoding="utf-8") for p in paths])
        | RunnableLambda(lambda contents: [{"java_content": c} for c in contents])
        | RunnableMap({"java_content": RunnablePassthrough()})
        | java_prompt
        | client
        | StrOutputParser()
    )

    java_summary = chain.invoke(java_files)
    return "[SUCCESS] Java source files summarized successfully."

# === AGENT 2: JUnit Generator ===
junit_suggestions = []

def generate_junit_tests(_: str) -> str:
    global java_summary

    if not java_summary:
        return "[SKIP] Java summary missing."

    client = get_openai_client()
    junit_prompt = PromptTemplate(
        input_variables=["java_summary"],
        template="""
You are a senior Java developer and test engineer.

Given a JSON structure of the Java codebase, generate accurate and complete JUnit 5 test classes for each:
- ServiceImpl
- Repository
- Controller

Each test class should:
- Be named like <ClassName>Test.java
- Use Mockito where needed
- Cover at least 80% of public methods
- Use realistic assertions
- Return output in the format:
{
  "file_name": "CandidateServiceImplTest.java",
  "package_path": "com/example/service",
  "code": "import org.junit.jupiter.api.Test; ..."
}

Process this input:
{java_summary}
"""
    )

    chain = LLMChain(llm=client, prompt=junit_prompt)
    result = chain.run(java_summary=java_summary)

    global junit_suggestions
    junit_suggestions = result
    return "[SUCCESS] JUnit classes generated."

# === MAIN ===
if __name__ == "__main__":
    print("\n=== Agent 1: Java Source Analysis ===")
    memory1 = ConversationBufferMemory(memory_key="chat_history", return_messages=True)

    agent1 = initialize_agent(
        tools=[
            Tool(name="ListJavaFiles", func=list_java_files, description="List all Java source files."),
            Tool(name="SummarizeJavaCode", func=summarize_java_code, description="Parse all Java classes and summarize.")
        ],
        llm=get_openai_client(),
        agent_type="openai-functions",
        memory=memory1,
        verbose=True
    )

    agent1.invoke("List and summarize Java code files for class dependencies and method map.")

    print("\n=== Agent 2: JUnit Generator ===")
    memory2 = ConversationBufferMemory(memory_key="chat_history", return_messages=True)

    agent2 = initialize_agent(
        tools=[
            Tool(name="GenerateJUnit", func=generate_junit_tests, description="Generate JUnit test classes from parsed structure.")
        ],
        llm=get_openai_client(),
        agent_type="openai-functions",
        memory=memory2,
        verbose=True
    )

    agent2.invoke("Generate JUnit tests with >80% coverage for all services, repositories, and controllers.")

    print("\n=== Output: Suggested JUnit Test Classes ===")
    print(junit_suggestions)
