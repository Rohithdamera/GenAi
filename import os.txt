import os
import json
from pathlib import Path
import gradio as gr
import re
from typing import List, Dict

from langchain.prompts import PromptTemplate
from langchain_openai import AzureChatOpenAI

# === Azure OpenAI Client ===
def get_openai_client():
    return AzureChatOpenAI(
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        deployment_name="Fourth_Chatbot",
        openai_api_key="",  # Use your actual key or env var
        openai_api_version="2024-08-01-preview",
        openai_api_type="azure",
        temperature=0.3,
        max_tokens=2000,
    )

llm = get_openai_client()

# === Global Stores ===
java_files: List[Path] = []
parsed_code_info: List[Dict] = []
junit_suggestions: List[Dict] = []

# === Step 1: Find Java Files Recursively ===
def find_java_files(path: str) -> List[Path]:
    base_path = Path(path)
    if not base_path.exists():
        raise FileNotFoundError(f"Path not found: {path}")
    all_java_files = list(base_path.rglob("*.java"))
    return all_java_files

# === Step 2: Extract Metadata from Java Files ===
def extract_class_metadata(java_paths: List[Path]) -> List[Dict]:
    prompt = PromptTemplate(
        input_variables=["source"],
        template="""
Analyze the following Java source code and return the following as JSON:
- class_name
- class_type (Controller, Service, Config, Model, etc.)
- package_path (from the package declaration)
- methods: list of public method names

Only return compact valid JSON. No extra commentary.

Java Source:
{source}
"""
    )
    chain = prompt | llm
    parsed = []

    for file_path in java_paths:
        try:
            source = file_path.read_text(encoding="utf-8")
            response = chain.invoke({"source": source})
            data = json.loads(response.content.strip())
            parsed.append(data)
        except Exception as e:
            print(f"[WARN] Failed to parse {file_path}: {e}")
    return parsed

# === Step 3: Generate JUnit Tests ===
def generate_junit_tests_from_metadata(parsed_info: List[Dict]) -> List[Dict]:
    prompt = PromptTemplate(
        input_variables=["class_name", "class_type", "package_path", "methods"],
        template="""
Write a full JUnit 5 test class for:
- Class Name: {class_name}
- Type: {class_type}
- Package: {package_path}
- Public Methods:
{methods}

Use proper annotations:
- Use @WebMvcTest and MockMvc for Controller
- Use @SpringBootTest or @ExtendWith(MockitoExtension.class) for Service/Config
- Include mocks and 1 test per method

Output valid Java code ONLY (no markdown, no explanation).
"""
    )
    chain = prompt | llm
    test_classes = []

    for item in parsed_info:
        try:
            result = chain.invoke({
                "class_name": item["class_name"],
                "class_type": item["class_type"],
                "package_path": item["package_path"],
                "methods": "\n".join(item["methods"]),
            })
            test_classes.append({
                "file_name": f"{item['class_name']}Test.java",
                "package_path": item["package_path"],
                "code": result.content.strip()
            })
        except Exception as e:
            print(f"[WARN] Could not generate test for {item['class_name']}: {e}")
    return test_classes

# === Step 4: Save Files & Return Code to UI ===
def save_and_format_output(junit_tests: List[Dict]) -> str:
    output = ""
    for test in junit_tests:
        folder = Path("generated_tests") / test["package_path"].replace(".", "/")
        folder.mkdir(parents=True, exist_ok=True)
        file_path = folder / test["file_name"]
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(test["code"])
        output += f"\n===== {test['file_name']} =====\n"
        output += test["code"]
        output += f"\n===== End of {test['file_name']} =====\n"
    return output.strip()

# === Main Function Called by UI ===
def process_java_project(prompt: str, history):
    try:
        path_match = re.search(r"([A-Za-z]:[\\/\w\-. ]+)", prompt)
        if not path_match:
            return "[ERROR] Please provide a valid Windows file path."

        project_path = path_match.group(1).strip()
        java_paths = find_java_files(project_path)
        if not java_paths:
            return "[INFO] No Java files found."

        parsed_info = extract_class_metadata(java_paths)
        if not parsed_info:
            return "[INFO] No parsable Java classes found."

        test_classes = generate_junit_tests_from_metadata(parsed_info)
        if not test_classes:
            return "[INFO] No JUnit tests could be generated."

        return save_and_format_output(test_classes)

    except Exception as e:
        return f"[ERROR] {str(e)}"

# === Gradio UI ===
chatbot_ui = gr.ChatInterface(
    fn=process_java_project,
    title="OSIF Co-Developer",
    description=(
        "ðŸ’¡ Paste a prompt like:\n"
        "`generate the junit for this project C:\\Users\\you\\Downloads\\my-java-project`\n\n"
        "I will scan, extract class info, and return full JUnit 5 test classes right here."
    ),
    theme="default"
)

if __name__ == "__main__":
    chatbot_ui.launch()
