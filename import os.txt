import os
import shutil
import zipfile
import json
from base64 import b64decode
import logging
from Crypto.Cipher import AES
import random
import string

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def unpad(data):
    return data[:-data[-1]]

def decrypt(data, key):
    try:
        cipher = AES.new(b64decode(key), AES.MODE_ECB)
        decrypted = cipher.decrypt(b64decode(data))
        return unpad(decrypted).decode()
    except Exception as e:
        logger.error(f"Decryption error: {e}")
        raise ValueError("Decryption failed.")

def unzip_to_temp(zip_bytes):
    base_path = "/tmp/extracted"
    if os.path.exists(base_path):
        shutil.rmtree(base_path)
    os.makedirs(base_path, exist_ok=True)

    with open("/tmp/upload.zip", "wb") as f:
        f.write(zip_bytes)

    with zipfile.ZipFile("/tmp/upload.zip", 'r') as zip_ref:
        zip_ref.extractall(base_path)

    return base_path

def find_html_with_xml(base_path):
    for root, _, files in os.walk(base_path):
        for file in files:
            if file.endswith(".html"):
                html_path = os.path.join(root, file)
                with open(html_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    if ".xml" in content:
                        return html_path, content
    raise FileNotFoundError("No HTML file with XML reference found in zip.")

def extract_xml_filename(html_content):
    index = html_content.find(".xml")
    if index == -1:
        return None

    start = index
    while start > 0 and html_content[start] not in ['"', "'", ">", "<", " ", '\n']:
        start -= 1

    return html_content[start+1:index+4]

def extract_connector_names(xml_path):
    connectors = set()
    with open(xml_path, 'r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            if "connector" in line.lower():
                parts = line.replace('<', '').replace('>', '').split()
                for part in parts:
                    if "connector" in part.lower():
                        val = part.split('=')[-1].strip('"').strip("'")
                        connectors.add(val)
    return list(connectors)

def find_raml_files_for_connectors(base_path, connectors):
    raml_files = []
    for root, _, files in os.walk(base_path):
        for file in files:
            if file.endswith(".raml"):
                for connector in connectors:
                    if connector in file:
                        raml_files.append(os.path.join(root, file))
    return list(set(raml_files))

def resolve_include_path(include_path, root_dir, current_dir):
    candidates = [
        os.path.join(current_dir, include_path),
        os.path.join(root_dir, include_path)
    ]
    for path in candidates:
        if os.path.isfile(path):
            return path

    for root, _, files in os.walk(root_dir):
        for f in files:
            if f == os.path.basename(include_path):
                return os.path.join(root, f)

    return None

def resolve_includes(raml_path, root_dir):
    resolved = []
    current_dir = os.path.dirname(raml_path)
    with open(raml_path, 'r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            if "!include" in line:
                prefix, include_path = line.strip().split("!include")
                prefix = prefix.strip()
                include_path = include_path.strip()
                full_path = resolve_include_path(include_path, root_dir, current_dir)
                if full_path:
                    with open(full_path, 'r', encoding='utf-8', errors='ignore') as inc:
                        resolved.append(f"{prefix} |\n")
                        for l in inc:
                            resolved.append("  " + l.strip())
                else:
                    resolved.append(line.strip() + "  # include not found")
            else:
                resolved.append(line.rstrip())
    return "\n".join(resolved)

def extract_endpoints(raml_text):
    return [line.strip() for line in raml_text.splitlines() if line.strip().startswith("/")]

def extract_fields(endpoint, raml_text):
    lines = raml_text.splitlines()
    fields = {}
    capture = False
    for line in lines:
        if line.strip() == endpoint:
            capture = True
        elif capture and line.strip().startswith("/"):
            break
        elif capture:
            if ':' in line:
                key = line.strip().split(":")[0]
                fields[key] = "string"
    return fields

def generate_value(data_type):
    if data_type == 'string':
        return ''.join(random.choices(string.ascii_letters, k=8))
    elif data_type == 'number':
        return random.randint(1, 100)
    elif data_type == 'boolean':
        return random.choice([True, False])
    else:
        return "sample"

def generate_payload(fields):
    return {k: generate_value(v) for k, v in fields.items()}

def mock_generate_payloads(raml_text):
    result = {}
    endpoints = extract_endpoints(raml_text)
    for ep in endpoints:
        fields = extract_fields(ep, raml_text)
        result[ep] = [generate_payload(fields), generate_payload(fields)]
    return result

def lambda_handler(event, context):
    try:
        if 'body' not in event or not event.get('isBase64Encoded'):
            raise ValueError("Invalid input. Expecting base64-encoded zip file.")

        zip_bytes = b64decode(event['body'])
        base_dir = unzip_to_temp(zip_bytes)

        html_path, html_content = find_html_with_xml(base_dir)
        xml_filename = extract_xml_filename(html_content)
        if not xml_filename:
            raise ValueError("No XML file referenced in HTML content.")

        xml_path = os.path.join(os.path.dirname(html_path), xml_filename)
        if not os.path.isfile(xml_path):
            raise FileNotFoundError(f"Referenced XML file not found: {xml_filename}")

        connectors = extract_connector_names(xml_path)
        if not connectors:
            raise ValueError("No connectors found in XML file.")

        raml_paths = find_raml_files_for_connectors(base_dir, connectors)
        if not raml_paths:
            raise ValueError("No matching RAML files found for extracted connectors.")

        all_payloads = {}
        for raml in raml_paths:
            resolved = resolve_includes(raml, base_dir)
            payloads = mock_generate_payloads(resolved)
            all_payloads.update(payloads)

        return {
            "statusCode": 200,
            "headers": {"Content-Type": "application/json"},
            "body": json.dumps(all_payloads)
        }

    except Exception as e:
        logger.error(f"Lambda error: {e}")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)})
        }
