def generate_junit_tests_from_metadata(parsed_info: List[Dict]) -> List[Dict]:
    ALLOWED_TYPES = {"Controller", "Service"}  # Only generate for these types

    # Build a dictionary of entity fields for realistic population
    entity_map = {
        item["class_name"]: item.get("entity_fields", [])
        for item in parsed_info
        if item.get("class_type") == "Entity"
    }

    prompt = PromptTemplate(
        input_variables=["class_name", "class_type", "package_path", "methods", "uses_repository", "entity_map"],
        template="""
Write a complete JUnit 5 test class for the following Java class.

Class Name: {class_name}
Type: {class_type}
Package: {package_path}
Public Methods:
{methods}
uses_repository: {uses_repository}

You also have access to the following entity definitions and their fields:
{entity_map}

Rules for Controller tests:
- Annotate with @WebMvcTest({class_name}.class) and no other class-level test annotation.
- Inject MockMvc with @Autowired.
- Inject ObjectMapper with @Autowired (do not manually create it).
- Mock the Service layer with @MockBean.
- Use `when(...).thenReturn(...)` from Mockito, never BDDMockito.
- Use JSON serialization via `objectMapper.writeValueAsString(...)` instead of hardcoded JSON strings.
- Match JSON property names and casing exactly as per the entity fields (preserve camel case or Pascal case exactly as in the entity).
- For collections, verify specific indexes with `jsonPath("$[0]....")` when appropriate.
- Use static imports for MockMvcRequestBuilders.* and MockMvcResultMatchers.*.

Rules for Service tests:
- No Spring annotations; instantiate service directly.
- No mocking unless uses_repository == true, in which case mock the repository with Mockito.
- Use AssertJ (`assertThat(...)`) instead of JUnit `assertEquals`.
- Populate all entity fields with realistic values:
    - String fields: `"John Doe"` or `"sampleString"` depending on context.
    - Long: `1L`
    - int: `123`
    - boolean: `true`
    - LocalDateTime: `"2025-07-25T10:00:00"` (string) or `LocalDateTime.now()` if needed.
    - UUID: `UUID.randomUUID().toString()`
- If an ID field is nullable, include a test that sets it to null before calling `add` method, and assert that an ID gets generated.
- Include assertions verifying that returned objects match what was stored.

General:
- Create one test method per public method in the target class.
- Include proper imports.
- Output only valid Java code â€” no explanations.
"""
    )

    chain = prompt | llm

    test_classes = []
    for item in parsed_info:
        if item["class_type"] not in ALLOWED_TYPES:
            continue
        try:
            result = chain.invoke({
                "class_name": item["class_name"],
                "class_type": item["class_type"],
                "package_path": item["package_path"],
                "methods": "\n".join(item["methods"]),
                "uses_repository": str(item.get("uses_repository", False)).lower(),
                "entity_map": json.dumps(entity_map, indent=2)
            })
            test_classes.append({
                "file_name": f"{item['class_name']}Test.java",
                "package_path": item["package_path"],
                "code": result.content.strip()
            })
        except Exception as e:
            print(f"[WARN] Could not generate test for {item['class_name']}: {e}")
    return test_classes
