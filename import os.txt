import os
import shutil
from pathlib import Path
import gradio as gr
import json
from langchain.prompts import PromptTemplate
from langchain_openai import AzureChatOpenAI

# === Azure OpenAI Client ===
def get_openai_client():
    return AzureChatOpenAI(
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        deployment_name="gpt-4_complex_conversions",
        openai_api_key="",
        openai_api_version="2024-08-01-preview",
        openai_api_type="azure",
        temperature=0.3,
        max_tokens=4000,
    )

llm = get_openai_client()

# === Step 1: Extract user intent ===
def extract_user_intent(user_input: str) -> dict:
    prompt = PromptTemplate(
        input_variables=["user_input"],
        template="""
From the following request, extract two things:

1. new_project_name → the new project name (e.g., AWS_Connector, GCP_Connector)  
2. reference_path → the given reference project path  

Return only valid JSON:
{{
  "new_project_name": "...",
  "reference_path": "..."
}}

User request:
{user_input}
"""
    )
    response = (prompt | llm).invoke({"user_input": user_input})
    return json.loads(response.content.strip())

# === Step 2: Detect old project name ===
def detect_old_project_name(reference_path: str) -> str:
    prompt = PromptTemplate(
        input_variables=["path"],
        template="""
You are given a reference project folder path: {path}.

From this path, identify the core project name (used in folder names, package names, and main class).  
Return only the project name string.
"""
    )
    response = (prompt | llm).invoke({"path": reference_path})
    return response.content.strip()

# === Step 3: AI-driven file rewrite ===
def ai_rewrite_file(source: str, old_name: str, new_name: str, filename: str, is_main: bool, is_test: bool) -> str:
    prompt = PromptTemplate(
        input_variables=["source", "old_name", "new_name", "filename", "is_main", "is_test"],
        template="""
You are refactoring a Java project.

Rules:
- Old project name: {old_name}
- New project name: {new_name}
- Replace {old_name} with {new_name} in:
  * package names
  * folder names (simulate consistency)
  * pom.xml identifiers
- If this file is main class (is_main = True), rename the class to {new_name}Application.
- If this file is test class (is_test = True), rename it to {new_name}ApplicationTests.
- Ensure imports, package declarations, and references are updated accordingly.
- Leave other business logic untouched.

File being processed: {filename}
Main class? {is_main}
Test class? {is_test}

File content:
{source}
"""
    )
    response = (prompt | llm).invoke(
        {
            "source": source,
            "old_name": old_name,
            "new_name": new_name,
            "filename": filename,
            "is_main": str(is_main),
            "is_test": str(is_test),
        }
    )
    return response.content.strip()

# === Step 4: Detect main/test class ===
def detect_main_class(source: str) -> bool:
    return "public static void main(" in source or "@SpringBootApplication" in source

def detect_test_class(filename: str) -> bool:
    return filename.lower().endswith("test.java")

# === Step 5: Rename folders recursively ===
def recursive_folder_rename(base_path: Path, old_name: str, new_name: str):
    # Rename from deepest paths first
    for path in sorted(base_path.rglob("*"), key=lambda p: len(str(p)), reverse=True):
        if old_name in path.name:
            new_path = path.with_name(path.name.replace(old_name, new_name))
            path.rename(new_path)

# === Step 6: Rewrite project ===
def rewrite_project(reference_path: str, old_project_name: str, new_project_name: str) -> str:
    ref_path = Path(reference_path)
    if not ref_path.exists():
        return f"[ERROR] Reference project not found: {reference_path}"

    target_base = Path("C:/Users/rdamera/Downloads/ddddd")
    target_path = target_base / new_project_name
    if target_path.exists():
        shutil.rmtree(target_path)

    # Copy structure
    shutil.copytree(ref_path, target_path)

    # Rename all folders/files containing old name
    recursive_folder_rename(target_path, old_project_name, new_project_name)

    # Rewrite contents
    for file_path in target_path.rglob("*"):
        if file_path.is_file() and file_path.suffix.lower() in [
            ".java", ".xml", ".yml", ".yaml", ".properties", ".json", ".md", ".txt"
        ]:
            try:
                source = file_path.read_text(encoding="utf-8", errors="ignore")
                is_main = detect_main_class(source)
                is_test = detect_test_class(file_path.name)
                updated = ai_rewrite_file(source, old_project_name, new_project_name, file_path.name, is_main, is_test)
                file_path.write_text(updated, encoding="utf-8")

                # If filename still contains old name, rename it too
                if old_project_name in file_path.name:
                    new_file_path = file_path.with_name(file_path.name.replace(old_project_name, new_project_name))
                    file_path.rename(new_file_path)

            except Exception as e:
                print(f"[WARN] Skipping {file_path}: {e}")

    return str(target_path)

# === Orchestration ===
def process_java_project(user_input: str, history):
    try:
        intent = extract_user_intent(user_input)
        reference_path = intent["reference_path"]
        new_project_name = intent["new_project_name"]

        old_project_name = detect_old_project_name(reference_path)

        new_path = rewrite_project(reference_path, old_project_name, new_project_name)
        return f"[SUCCESS] Project '{new_project_name}' created at {new_path}"

    except Exception as e:
        return f"[ERROR] {str(e)}"

# === UI ===
chatbot_ui = gr.ChatInterface(
    fn=process_java_project,
    title="AI Java Project Generator",
    description="Generate a Java project by cloning a reference and renaming folders, packages, pom.xml, main/test classes with your provided project name.",
    theme="default",
)

if __name__ == "__main__":
    chatbot_ui.launch()


Now this version ensures:

All folder names containing the old project name are replaced with the new name (deep recursive rename).

Main application class is detected (main() or @SpringBootApplication) → renamed to {new_project_name}Application.

Test class renamed to {new_project_name}ApplicationTests.

pom.xml, package declarations, and imports updated via AI rewrite.

No hardcoding of AWS_Connector or osif_java_cg_candidate.


Do you also want me to add auto-normalization (so AWS_Connector → package folder aws_connector) to make it Java package compliant?

