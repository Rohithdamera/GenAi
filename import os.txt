# Full updated Lambda function

import os
import shutil
import zipfile
import json
from base64 import b64decode
import logging
import random
import string

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ---------------- MOCK OPENAI CLIENT ----------------
def mock_openai_client(model_instance_name):
    class MockClient:
        def invoke(self, messages):
            raml_content = messages[0]['content']
            endpoints = extract_endpoints_from_raml(raml_content)
            example_structures = extract_example_structures(raml_content)
            payloads = generate_payloads(endpoints, example_structures)
            return type('obj', (object,), {'content': json.dumps(payloads)})
    return MockClient()

# ---------------- HELPER METHODS ----------------

def extract_endpoints_from_raml(raml_content):
    return [line.strip() for line in raml_content.splitlines() if line.strip().startswith('/')]

def extract_example_structures(raml_content):
    structures = {}
    lines = raml_content.splitlines()
    current_endpoint = None
    inside_example = False
    buffer = []
    for line in lines:
        if line.strip().startswith('/'):
            if current_endpoint and buffer:
                try:
                    structures[current_endpoint] = json.loads("\n".join(buffer))
                except Exception:
                    pass
            current_endpoint = line.strip()
            buffer = []
            inside_example = False
        elif 'example:' in line:
            inside_example = True
            buffer = []
        elif inside_example:
            if line.startswith(' '):
                buffer.append(line.strip())
            else:
                inside_example = False
    if current_endpoint and buffer:
        try:
            structures[current_endpoint] = json.loads("\n".join(buffer))
        except Exception:
            pass
    return structures

def generate_payloads(endpoints, example_structures):
    def generate_payload(template):
        if isinstance(template, dict):
            return {k: generate_payload(v) for k, v in template.items()}
        elif isinstance(template, list):
            return [generate_payload(template[0]) if template else []]
        elif isinstance(template, str):
            return ''.join(random.choices(string.ascii_letters, k=8))
        elif isinstance(template, bool):
            return random.choice([True, False])
        elif isinstance(template, int) or isinstance(template, float):
            return random.randint(1, 10000)
        else:
            return None

    payloads = {}
    for endpoint in endpoints:
        example = example_structures.get(endpoint)
        if example:
            payloads[endpoint] = [
                generate_payload(example),
                generate_payload(example)
            ]
    return payloads

# ---------------- FILE PROCESSING ----------------

def unzip_raml(zip_bytes, extract_dir="/tmp/temp_raml"):
    if os.path.exists(extract_dir):
        shutil.rmtree(extract_dir)
    os.makedirs(extract_dir, exist_ok=True)
    zip_path = "/tmp/uploaded.zip"
    with open(zip_path, "wb") as f:
        f.write(zip_bytes)
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        zip_ref.extractall(extract_dir)
    return extract_dir

def find_main_raml_file(base_dir):
    for root, _, files in os.walk(base_dir):
        for file in files:
            if file.endswith(".raml"):
                full_path = os.path.join(root, file)
                with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                    if "#%RAML 1.0" in f.readline():
                        return full_path
    raise FileNotFoundError("Main RAML file not found.")

def resolve_include_path(include_path, root_dir, current_dir):
    full_path = os.path.normpath(os.path.join(current_dir, include_path))
    if os.path.isfile(full_path): return full_path
    full_path = os.path.normpath(os.path.join(root_dir, include_path))
    if os.path.isfile(full_path): return full_path
    for root, _, files in os.walk(root_dir):
        for f in files:
            if f == os.path.basename(include_path):
                return os.path.join(root, f)
    return None

def resolve_includes_in_raml(file_path, root_dir):
    resolved_lines = []
    current_dir = os.path.dirname(file_path)
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
        for line in file:
            if "!include" in line:
                parts = line.strip().split("!include")
                prefix = parts[0].strip()
                include_path = parts[1].strip()
                include_file = resolve_include_path(include_path, root_dir, current_dir)
                if include_file and os.path.exists(include_file):
                    with open(include_file, 'r', encoding='utf-8', errors='ignore') as inc_file:
                        resolved_lines.append(f"{prefix} |\n")
                        for inc_line in inc_file.read().splitlines():
                            resolved_lines.append(f"  {inc_line}")
                else:
                    resolved_lines.append(f"{line.strip()}  # Include not found")
            else:
                resolved_lines.append(line.rstrip())
    return "\n".join(resolved_lines)

# ---------------- MAIN INVOKE ----------------

def analyze_raml_with_openai(client, resolved_raml_content):
    prompt = (
        "You are a RAML test data generator.\n"
        "Below is a RAML specification with all includes already resolved (traits, examples, schemas, etc).\n"
        "Use the structure and types defined in the examples.\n\n"
        "For each endpoint, generate exactly two unique, complete, and randomized test payloads.\n"
        "Guidelines:\n"
        "- Do not invent or add any extra fields.\n"
        "- Follow the exact field names and structures from the examples.\n"
        "- Preserve types: string, number, boolean, array, object.\n"
        "- All fields must have realistic dummy values of the correct type.\n"
        "- Do not use empty/null unless a field is explicitly nullable.\n"
        "- No hardcoding like 'name', 'count', 'id'. Use randomized realistic values.\n\n"
        "Return a JSON object with this structure:\n"
        "{\n"
        "  \"/endpoint1\": [payload1, payload2],\n"
        "  \"/endpoint2\": [payload1, payload2]\n"
        "}\n\n"
        "Here is the RAML project (fully inlined):\n"
    )
    response = client.invoke([{"content": prompt + "\n\n" + resolved_raml_content}])
    return response.content

# ---------------- AWS LAMBDA ENTRY ----------------

def lambda_handler(event, context):
    logger.info("Lambda invoked.")
    try:
        if 'body' not in event or not event.get('isBase64Encoded', False):
            raise ValueError("File content is missing or not base64-encoded.")
        zip_bytes = b64decode(event['body'])

        headers = event.get('headers', {})
        model_instance_name = (
            headers.get('model_instance_name') or
            headers.get('Model_Instance_Name') or
            os.environ.get('DEFAULT_MODEL_INSTANCE_NAME', 'default-model')
        )

        extracted_dir = unzip_raml(zip_bytes)
        main_raml_file = find_main_raml_file(extracted_dir)
        resolved_raml = resolve_includes_in_raml(main_raml_file, extracted_dir)

        client = mock_openai_client(model_instance_name)
        final_output = analyze_raml_with_openai(client, resolved_raml)

        return {
            "statusCode": 200,
            "headers": {"Content-Type": "application/json"},
            "body": final_output
        }

    except Exception as e:
        logger.error(f"Error during execution: {e}")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)})
        }
