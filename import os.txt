import asyncio
import json
import nest_asyncio
import pandas as pd
import uuid
import time

from mcp import ClientSession
from mcp.client.sse import sse_client
from langchain.chat_models import AzureChatOpenAI
from langchain.agents import Tool, initialize_agent
from langchain.agents.agent_types import AgentType
from langchain.memory import ConversationBufferMemory

nest_asyncio.apply()

# ------------ Session Management (in-memory TTL 30min) ------------ #
SESSION_TTL = 30 * 60
chat_sessions = {}
def create_session():
    cid = str(uuid.uuid4())
    chat_sessions[cid] = {"start": time.time(), "messages": []}
    return cid

def add_msg(cid, role, text):
    if cid in chat_sessions:
        chat_sessions[cid]["messages"].append({"role": role, "text": text})

def cleanup_sessions():
    now = time.time()
    expired = [cid for cid,data in chat_sessions.items() if now - data["start"] > SESSION_TTL]
    for cid in expired:
        del chat_sessions[cid]

# ------------ OpenAI Client ------------ #
def get_openai_client():
    return AzureChatOpenAI(
        azure_deployment="Fourth_Chatbot",
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        openai_api_version="2024-08-01-preview",
        openai_api_key="",  # YOUR KEY
        temperature=0.3,
        max_tokens=2000,
    )

# ------------ Tool Infrastructure ------------ #
sse_url = "https://.../sse"

def sync_call(tool_name, params):
    async def c():
        async with sse_client(url=sse_url) as streams:
            async with ClientSession(*streams) as sess:
                await sess.initialize()
                return await sess.call_tool(tool_name, params)
    return asyncio.get_event_loop().run_until_complete(c())

def fetch_tools():
    async def c():
        async with sse_client(url=sse_url) as streams:
            async with ClientSession(*streams) as sess:
                await sess.initialize()
                return await sess.list_tools()
    return asyncio.get_event_loop().run_until_complete(c())

def build_tools():
    raw = fetch_tools()
    tools = []
    for t in getattr(raw, "tools", []):
        name, schema = t.name, t.inputSchema or {}
        req = schema.get("required", [])

        def make_fn(n=name, req=req):
            def fn(input_str: str) -> str:
                data = json.loads(input_str) if input_str else {}
                for k in req:
                    data.setdefault(k, "")
                resp = sync_call(n, data)
                return json.dumps(resp, indent=2)
            return fn

        tools.append(Tool(name=name, func=make_fn(),
                          description=f"{t.description} | required: {req}", return_direct=False))
    return tools

# ------------ Table Utility ------------ #
def to_table(data):
    try:
        j = json.loads(data)
        df = pd.DataFrame(j) if isinstance(j, list) else pd.DataFrame([j])
        return df.to_string(index=False)
    except:
        return data

# ------------ Agent Prompt ------------ #
PROMPT = """
You can create employees via CreateEmployee. Read its required inputSchema to request all fields. 
Validate types, formats, then invoke once. Present response status in a small table (Status, Message).
"""

# ------------ Build Agent ------------ #
def build_agent():
    memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)
    agent = initialize_agent(
        tools=build_tools(),
        llm=get_openai_client(),
        agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
        memory=memory, verbose=True,
        max_iterations=5,
        agent_kwargs={"prefix": PROMPT}
    )
    return agent, memory

# ------------ CLI Loop ------------ #
if __name__=="__main__":
    cid = create_session()
    agent, mem = build_agent()
    print("Session ID:", cid)

    while True:
        cleanup_sessions()
        q = input("> ").strip()
        if q.lower() in ("exit","quit"):
            break
        add_msg(cid, "user", q)

        if "chat history" in q.lower():
            print("History:")
            for m in mem.chat_memory.messages:
                print(m.role, ":", m.content)
            continue

        resp = agent.invoke({"input": q})["output"]
        add_msg(cid, "assistant", resp)
        print(to_table(resp))
