import os
import shutil
import zipfile
import json
import logging
import random
import string
from base64 import b64decode

# Setup logger
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ========== Data Generation ==========

def random_value(template):
    if isinstance(template, str):
        if '/' in template or ':' in template:
            return f"{random.randint(1, 28):02}/{random.randint(1, 12):02}/2025 {random.randint(0, 23):02}:{random.randint(0, 59):02}:{random.randint(0, 59):02}"
        elif len(template) in (32, 36):
            return ''.join(random.choices(string.hexdigits.lower(), k=36))
        elif template.isdigit():
            return ''.join(random.choices(string.digits, k=len(template)))
        return ''.join(random.choices(string.ascii_letters + string.digits, k=len(template)))
    elif isinstance(template, int):
        return random.randint(1000, 9999)
    elif isinstance(template, float):
        return round(random.uniform(1.0, 9999.0), 2)
    elif isinstance(template, bool):
        return random.choice([True, False])
    elif isinstance(template, list):
        return [random_value(template[0]) if template else []]
    elif isinstance(template, dict):
        return {k: random_value(v) for k, v in template.items()}
    return None

# ========== ZIP Extraction ==========

def unzip_to_tmp(zip_bytes, extract_dir="/tmp/unzipped_raml"):
    if os.path.exists(extract_dir):
        shutil.rmtree(extract_dir)
    os.makedirs(extract_dir, exist_ok=True)
    zip_path = "/tmp/input.zip"
    with open(zip_path, "wb") as f:
        f.write(zip_bytes)
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        zip_ref.extractall(extract_dir)
    return extract_dir

# ========== Main RML File Detection ==========

def find_main_rml_file(base_dir):
    for root, _, files in os.walk(base_dir):
        for file in files:
            if file.endswith(".rml"):
                full_path = os.path.join(root, file)
                with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                    header = f.readline()
                    if "#%RAML 1.0" in header:
                        return full_path
    raise FileNotFoundError("Main .rml file not found.")

# ========== Extract POST Paths ==========

def extract_post_paths(rml_content):
    post_paths = []
    lines = rml_content.splitlines()
    current_path = None
    for line in lines:
        stripped = line.strip()
        if stripped.startswith('/'):
            current_path = stripped
        elif stripped.lower().startswith('post') and current_path:
            post_paths.append(current_path)
    return post_paths

# ========== Find Reference RML Files ==========

def find_reference_rml_files(base_dir):
    rml_files = []
    for root, _, files in os.walk(base_dir):
        for file in files:
            if file.endswith(".rml"):
                rml_files.append(os.path.join(root, file))
    return rml_files

# ========== Extract JSON from RML ==========

def extract_json_structure(file_path):
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
        content = f.read()

    # Try to find a JSON object in the file
    try:
        first_brace = content.index('{')
        last_brace = content.rindex('}')
        json_text = content[first_brace:last_brace + 1]
        return json.loads(json_text)
    except Exception as e:
        logger.warning(f"JSON structure not found in: {file_path}")
        return None

# ========== Match Reference to POST Path ==========

def match_reference_to_post(post_path, reference_files):
    for ref_file in reference_files:
        if post_path.strip("/").lower() in ref_file.lower().replace("\\", "/"):
            json_data = extract_json_structure(ref_file)
            if json_data:
                return json_data
    return None

# ========== Lambda Handler ==========

def lambda_handler(event, context):
    logger.info("Lambda function started.")
    try:
        if 'body' not in event or not event.get('isBase64Encoded', False):
            raise ValueError("Missing or invalid input zip file.")

        zip_bytes = b64decode(event['body'])
        base_dir = unzip_to_tmp(zip_bytes)

        main_rml_path = find_main_rml_file(base_dir)
        with open(main_rml_path, 'r', encoding='utf-8', errors='ignore') as f:
            main_rml_content = f.read()

        post_paths = extract_post_paths(main_rml_content)
        logger.info(f"POST endpoints found: {post_paths}")

        reference_files = find_reference_rml_files(base_dir)
        logger.info(f"Reference RML files found: {len(reference_files)}")

        result = {}
        for post_path in post_paths:
            structure = match_reference_to_post(post_path, reference_files)
            if structure:
                result[post_path] = [
                    random_value(structure),
                    random_value(structure)
                ]
            else:
                logger.warning(f"No matching reference file for {post_path}")

        return {
            "statusCode": 200,
            "headers": {"Content-Type": "application/json"},
            "body": json.dumps(result, indent=2)
        }

    except Exception as e:
        logger.error(f"Lambda execution failed: {e}")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)})
        }
