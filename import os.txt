import asyncio
import json
import time
import uuid
import nest_asyncio
import pandas as pd

from mcp import ClientSession
from mcp.client.sse import sse_client
from langchain.chat_models import AzureChatOpenAI
from langchain.agents import Tool, initialize_agent
from langchain.agents.agent_types import AgentType

nest_asyncio.apply()

# —————————————————————————————
# Session Management with TTL
# —————————————————————————————
chat_sessions = {}
SESSION_TTL = 30 * 60  # 30 minutes

def create_session():
    cid = str(uuid.uuid4())
    chat_sessions[cid] = {"created_at": time.time(), "messages": []}
    return cid

def add_message(cid, role, content):
    if cid in chat_sessions:
        chat_sessions[cid]["messages"].append({"role": role, "content": content})

def get_history(cid):
    return chat_sessions.get(cid, {}).get("messages", [])

def cleanup_sessions():
    now = time.time()
    expired = [cid for cid, s in chat_sessions.items() if now - s["created_at"] > SESSION_TTL]
    for cid in expired:
        del chat_sessions[cid]

# —————————————————————————————
# Azure OpenAI Client
# —————————————————————————————
def get_openai_client():
    return AzureChatOpenAI(
        azure_deployment="Fourth_Chatbot",
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        openai_api_version="2024-08-01-preview",
        azure_openai_api_key="",  # ← Add your key
        temperature=0.3,
        max_tokens=2000,
    )

# —————————————————————————————
# MCP Tool Integration
# —————————————————————————————
sse_url = "https://mcp-server-sse-cg-employees-sandbox-6b0n6.dw4w1g-2.gbr-e1.cloudhub.io/sse"

def sync_call_tool(tool_name: str, params: dict):
    async def call():
        async with sse_client(url=sse_url) as streams:
            async with ClientSession(*streams) as session:
                await session.initialize()
                return await session.call_tool(tool_name, params)
    return asyncio.get_event_loop().run_until_complete(call())

def fetch_all_tools():
    async def fetch():
        async with sse_client(url=sse_url) as streams:
            async with ClientSession(*streams) as session:
                await session.initialize()
                return await session.list_tools()
    return asyncio.get_event_loop().run_until_complete(fetch())

def get_tools():
    raw = fetch_all_tools()
    tools = []
    for t in getattr(raw, "tools", []):
        name = t.name
        req = t.inputSchema.get("required", []) if t.inputSchema else []
        def make_fn(tool_name=name, required_fields=req):
            def fn(input_str: str) -> str:
                try:
                    parsed = json.loads(input_str) if input_str else {}
                except:
                    parsed = {}
                for k in required_fields:
                    parsed.setdefault(k, "")
                try:
                    res = sync_call_tool(tool_name, parsed)
                    return json.dumps(res, indent=2, default=str)
                except Exception as e:
                    return f"[ERROR] {tool_name}: {str(e)}"
            return fn
        tools.append(Tool(name=name, func=make_fn(), description=t.description or "", return_direct=False))
    return tools

# —————————————————————————————
# Output Formatter → Table
# —————————————————————————————
def render_table(text: str) -> str:
    try:
        data = json.loads(text)
        if isinstance(data, list):
            df = pd.DataFrame(data)
        elif isinstance(data, dict):
            df = pd.DataFrame([data])
        else:
            return text
        return df.to_string(index=False)
    except:
        return text

# —————————————————————————————
# Agent Prompt Instructions
# —————————————————————————————
CUSTOM_PROMPT = """
You are a helpful assistant with access to employee and project tools.
- Try multiple tools if needed—don’t stop on failure.
- Use returned IDs to fetch more data via other tools.
- Format results as plain tables only (CSV/text).
- Cleanly retry or correct attempts, especially for create operations.
"""

# —————————————————————————————
# Build ReAct Agent
# —————————————————————————————
def build_agent():
    tools = get_tools()
    llm = get_openai_client()
    return initialize_agent(
        tools=tools,
        llm=llm,
        agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
        verbose=True,
        max_iterations=6,
        handle_parsing_errors=True,
        agent_kwargs={"prefix": CUSTOM_PROMPT}
    )

# —————————————————————————————
# Run CLI Session
# —————————————————————————————
if __name__ == "__main__":
    print("=== MCP Agent Ready ===")
    agent = build_agent()
    cid = create_session()
    print(f"Session ID: {cid}")

    while True:
        cleanup_sessions()
        user = input("\nYour question: ").strip()
        if user.lower() in ("exit", "quit"):
            print("Ending session.")
            break

        add_message(cid, "user", user)

        # Handle chat-history inline
        if "chat history" in user.lower():
            msgs = get_history(cid)
            print("\n[Chat History]")
            for i, m in enumerate(msgs):
                print(f"{i+1}. {m['role'].title()}: {m['content']}")
            continue

        try:
            response = agent.invoke({"input": user})["output"]
            print("\nAnswer:\n", render_table(response))
            add_message(cid, "assistant", response)
        except Exception as e:
            print("Error:", e)
