import os
import shutil
from pathlib import Path
import gradio as gr
import json

from langchain.prompts import PromptTemplate
from langchain_openai import AzureChatOpenAI

# === Azure OpenAI Client ===
def get_openai_client():
    return AzureChatOpenAI(
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        deployment_name="gpt-4_complex_conversions",
        openai_api_key="",
        openai_api_version="2024-08-01-preview",
        openai_api_type="azure",
        temperature=0.4,
        max_tokens=4000,
    )

llm = get_openai_client()

# === Step 1: Extract project name + reference path ===
def extract_user_intent(user_input: str) -> dict:
    prompt = PromptTemplate(
        input_variables=["user_input"],
        template="""
From the following user request, extract the information.

Return ONLY valid JSON with:
{{
  "new_project_name": "AWS_Connector",
  "reference_path": "C:/Users/abc/Downloads/xyz"
}}

User request:
{user_input}
"""
    )
    response = (prompt | llm).invoke({"user_input": user_input})
    return json.loads(response.content.strip())

# === Step 2: Analyze structure & decide what to regenerate ===
def analyze_structure(reference_path: str, new_project_name: str) -> dict:
    structure = []
    for root, dirs, files in os.walk(reference_path):
        rel_root = os.path.relpath(root, reference_path)
        if rel_root == ".":
            rel_root = ""
        structure.append({"path": rel_root, "dirs": dirs, "files": files})

    prompt = PromptTemplate(
        input_variables=["structure", "new_name"],
        template="""
You are generating a new Java project based on a reference structure.

Rules:
- Project must be renamed to {new_name}.
- Keep folder/package structure, but rename references.
- In "main" package: generate only ONE Application class (with main method).
- In "service", "controller", "client", "config" etc.: generate only EMPTY skeleton classes (no business logic).
- In "test": regenerate test skeletons with updated references.
- Do not carry over old reference logic, only generate clean structure.

Return ONLY valid JSON like this:
{{
  "folders_to_keep": ["src/main/java/integration/{new_name}/service", "src/main/java/integration/{new_name}/controller"],
  "files_to_generate": {{
    "src/main/java/integration/{new_name}/{new_name}Application.java": "Application",
    "src/main/java/integration/{new_name}/service/ServiceSkeleton.java": "Skeleton",
    "src/test/java/integration/{new_name}/{new_name}ApplicationTest.java": "Test"
  }}
}}

Reference structure:
{structure}
"""
    )
    response = (prompt | llm).invoke({"structure": json.dumps(structure), "new_name": new_project_name})
    return json.loads(response.content.strip())

# === Step 3: AI generates file content ===
def generate_file_content(file_type: str, file_path: str, new_project_name: str) -> str:
    prompt = PromptTemplate(
        input_variables=["file_type", "file_path", "new_name"],
        template="""
Generate a Java file.

Type: {file_type}
Path: {file_path}
Project name: {new_name}

Rules:
- For Application: generate a proper Spring Boot (or plain) main class with main().
- For Skeleton: generate an empty public class/interface with only package + class declaration.
- For Test: generate a minimal JUnit test skeleton with correct package + class name.
- Do not include old reference logic, only regenerate clean compilable code.
"""
    )
    response = (prompt | llm).invoke({"file_type": file_type, "file_path": file_path, "new_name": new_project_name})
    return response.content.strip()

# === Step 4: Rewrite Project ===
def rewrite_project(reference_path: str, new_project_name: str) -> str:
    ref_path = Path(reference_path)
    if not ref_path.exists():
        return f"[ERROR] Reference project not found: {reference_path}"

    target_base = Path("C:/Users/rdamera/javaproj")
    target_path = target_base / new_project_name
    if target_path.exists():
        shutil.rmtree(target_path)
    target_path.mkdir(parents=True)

    # Analyze structure & decide what to generate
    plan = analyze_structure(reference_path, new_project_name)

    # Recreate folder structure
    for folder in plan.get("folders_to_keep", []):
        (target_path / folder).mkdir(parents=True, exist_ok=True)

    # Generate files
    for rel_path, file_type in plan.get("files_to_generate", {}).items():
        abs_path = target_path / rel_path
        abs_path.parent.mkdir(parents=True, exist_ok=True)
        content = generate_file_content(file_type, rel_path, new_project_name)
        abs_path.write_text(content, encoding="utf-8")

    return str(target_path)

# === Main Orchestration ===
def process_java_project(user_input: str, history):
    try:
        intent = extract_user_intent(user_input)
        reference_path = intent["reference_path"]
        new_project_name = intent["new_project_name"]

        new_path = rewrite_project(reference_path, new_project_name)

        return f"[SUCCESS] Project '{new_project_name}' created at {new_path}"

    except Exception as e:
        return f"[ERROR] {str(e)}"

# === Gradio UI ===
chatbot_ui = gr.ChatInterface(
    fn=process_java_project,
    title="AI Java Project Generator",
    description="Provide a reference project path and a new project name. AI will regenerate the project structure, Application class, and skeletons without copying reference logic.",
    theme="default",
)

if __name__ == "__main__":
    chatbot_ui.launch()
