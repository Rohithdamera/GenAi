import os
import logging
import json
from base64 import b64decode
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from langchain_community.chat_models import AzureChatOpenAI
from langchain.schema import HumanMessage
import tempfile
import openpyxl
from openpyxl.utils import column_index_from_string

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()

# AES Decryption
def decrypt(data, key):
    cipher = AES.new(b64decode(key), AES.MODE_ECB)
    decrypted_data = cipher.decrypt(b64decode(data))
    decrypted_data = unpad(decrypted_data, AES.block_size)
    return decrypted_data.decode()

# Azure OpenAI Client
def get_openai_client(model_instance_name):
    aes_key_base64 = os.environ['AES_KEY']
    encrypted_api_base = os.environ['ENCRYPTED_API_BASE']
    encrypted_api_key = os.environ['ENCRYPTED_API_KEY']
    api_version = os.environ['AZURE_API_VERSION']

    decrypted_api_base = decrypt(encrypted_api_base, aes_key_base64)
    decrypted_api_key = decrypt(encrypted_api_key, aes_key_base64)

    if not decrypted_api_base.endswith('/'):
        decrypted_api_base += '/'

    return AzureChatOpenAI(
        deployment_name=model_instance_name,
        openai_api_base=decrypted_api_base,
        openai_api_key=decrypted_api_key,
        openai_api_version=api_version,
        temperature=0.4,
        max_tokens=4096
    )

# Convert Excel column letter to zero-based index
def col_letter_to_index(col_letter):
    return column_index_from_string(col_letter.upper()) - 1

# Extract Excel content dynamically
def extract_excel_data(file_path, sheet_name, source_col, logic_col, target_col):
    try:
        wb = openpyxl.load_workbook(file_path, data_only=True)
        sheet = wb[sheet_name]
        data = []
        for row in sheet.iter_rows(min_row=2, values_only=True):  # Skip header
            source = row[source_col]
            logic = row[logic_col]
            target = row[target_col]
            if source and target:
                data.append({
                    "source": source,
                    "logic": logic or "",
                    "target": target
                })
        return data
    except Exception as e:
        logger.error(f"Failed to extract Excel data: {e}")
        return []

# Build DataWeave prompt
def build_dataweave_prompt(extracted_data):
    prompt = (
        "Write a DataWeave script by referring to the uploaded Excel file named {file_name}, "
        "specifically the sheet named {sheet_name}.\n"
        "- Column {source_system_column} contains source field details.\n"
        "- Column {target_system_column} contains target field details.\n"
        "- Column {business_logic_column} contains the business logic for DataWeave transformations.\n"
        "This DataWeave script should be optimized to handle large data sets efficiently. "
        "Use only functions available in DataWeave as documented here: "
        "https://docs.mulesoft.com/dataweave/latest/dw-functions#dw_modules.\n"
    )
    prompt += "\nHere is the extracted data from the Excel sheet:\n"
    for row in extracted_data:
        prompt += f"- Source: {row['source']}, Target: {row['target']}, Logic: {row['logic']}\n"
    return prompt

# Lambda handler
def lambda_handler(event, context):
    try:
        headers = event.get("headers", {}) or {}
        model_instance = headers.get("model_instance_name", "")
        query = event.get("queryStringParameters", {}) or {}

        # Extract parameters from query
        file_name = query.get("file_name", "uploaded_file.xlsx")
        sheet_name = query.get("sheet_name")
        source_col = col_letter_to_index(query.get("source_system_column"))
        target_col = col_letter_to_index(query.get("target_system_column"))
        logic_col = col_letter_to_index(query.get("business_logic_column"))

        if not all([sheet_name, source_col is not None, target_col is not None, logic_col is not None]):
            raise ValueError("Missing one or more required query parameters.")

        if not event.get("isBase64Encoded", False):
            raise ValueError("Expected base64-encoded binary file")

        body_b64 = event.get("body", "")
        if not body_b64:
            raise ValueError("No file content found in the request body")

        body = b64decode(body_b64)
        with tempfile.NamedTemporaryFile(delete=False, suffix=".xlsx") as temp_file:
            temp_file.write(body)
            temp_file_path = temp_file.name

        extracted_data = extract_excel_data(temp_file_path, sheet_name, source_col, logic_col, target_col)

        prompt = build_dataweave_prompt(extracted_data)

        instructions = """
As a seasoned expert in MuleSoft Integration Services, you specialize in advanced data transformation and integration techniques, focusing on DataWeave transformations, JSON and XML handling, and complex data mappings. 
You excel in designing and implementing robust data transformation flows that facilitate the integration. 
This involves not only transforming and mapping data but also ensuring data consistency and integrity throughout the process. 
You can refer to this URL for DataWeave syntax: https://docs.mulesoft.com/dataweave/latest/dw-functions#dw_modules
"""

        full_prompt = instructions + "\n" + prompt

        client = get_openai_client(model_instance)
        response = client.invoke([
            HumanMessage(content=full_prompt),
            HumanMessage(content="Generate the DataWeave script.")
        ])

        final_result = response.content.strip()

        return {
            "statusCode": 200,
            "headers": {"Content-Type": "text/plain"},
            "body": final_result
        }

    except Exception as e:
        logger.error(f"Error: {e}")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)})
        }
