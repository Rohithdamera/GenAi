import os
import json
import base64
import zipfile
import tempfile
import shutil
from pathlib import Path
from langchain.prompts import PromptTemplate
from langchain_core.runnables import RunnableSequence
from langchain.tools import Tool
from langchain.agents import initialize_agent
from langchain_openai import AzureChatOpenAI

import logging
from base64 import b64decode
from Crypto.Cipher import AES

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()

# === OpenAI Azure Client ===
def unpad(data):
    return data[:-data[-1]]

def decrypt(data, key):
    cipher = AES.new(b64decode(key), AES.MODE_ECB)
    decrypted_data = cipher.decrypt(b64decode(data))
    return unpad(decrypted_data).decode()

def get_openai_client(model_instance_name=None):
    aes_key = os.environ['AES_KEY']
    encrypted_base = os.environ['ENCRYPTED_API_BASE']
    encrypted_key = os.environ['ENCRYPTED_API_KEY']
    api_version = os.environ['AZURE_API_VERSION']
    deployment = model_instance_name or os.environ['DEPLOYMENT_NAME']
    base = decrypt(encrypted_base, aes_key)
    key = decrypt(encrypted_key, aes_key)
    if not base.endswith('/'):
        base += '/'
    return AzureChatOpenAI(
        deployment_name=deployment,
        openai_api_base=base,
        openai_api_key=key,
        openai_api_version=api_version
    )

# === LangChain Tools (same as yours) ===
java_files = []
parsed_code_info = []
junit_suggestions = []

def list_java_files(directory: str) -> str:
    global java_files
    java_files = list(Path(directory).rglob("*.java"))
    return f"[FOUND] {len(java_files)} Java files."

def extract_code_info(_: str) -> str:
    global java_files, parsed_code_info
    if not java_files:
        return "[SKIP] No Java files to parse."
    parsed_code_info.clear()
    prompt = PromptTemplate(input_variables=["source"], template="""
Analyze the following Java source code and return the following as JSON:
- class_name
- class_type (Controller, Service, Config, Model, etc.)
- package_path (from the package declaration)
- methods: list of public method names

Only return compact valid JSON. No extra commentary.

Java Source:
{source}
""")
    chain = prompt | get_openai_client()
    for fp in java_files:
        try:
            content = fp.read_text(encoding="utf-8")
            result = chain.invoke({"source": content})
            j = json.loads(result.content.strip())
            if "class_name" in j:
                parsed_code_info.append(j)
        except Exception as e:
            logger.error("Parsing %s failed: %s", fp.name, e)
    return f"[SUCCESS] Parsed {len(parsed_code_info)} files."

def generate_junit_tests(_: str) -> str:
    global parsed_code_info, junit_suggestions
    junit_suggestions.clear()
    if not parsed_code_info:
        return "[SKIP] No parsed classes."
    prompt = PromptTemplate(input_variables=["class_name","class_type","package_path","methods"], template="""
Write a full JUnit 5 test class for:
- Class Name: {class_name}
- Type: {class_type}
- Package: {package_path}
- Public Methods:
{methods}

Use proper annotations:
- Use @WebMvcTest and MockMvc for Controller
- Use @SpringBootTest or @ExtendWith(MockitoExtension.class) for Service/Config
- Include mocks and 1 test per method

Output valid Java code ONLY (no markdown, no explanation).
""")
    chain = prompt | get_openai_client()
    for item in parsed_code_info:
        try:
            result = chain.invoke({
                "class_name": item["class_name"],
                "class_type": item["class_type"],
                "package_path": item["package_path"],
                "methods": "\n".join(item["methods"])
            })
            junit_suggestions.append({
                "file_name": f"{item['class_name']}Test.java",
                "package_path": item["package_path"],
                "code": result.content.strip()
            })
        except Exception as e:
            logger.error("Generate test for %s failed: %s", item.get("class_name"), e)
    return f"[SUCCESS] Generated {len(junit_suggestions)} test classes."

def save_and_collect(_: str) -> str:
    global junit_suggestions
    results = []
    for tst in junit_suggestions:
        results.append({
            "file_name": tst["file_name"],
            "package_path": tst["package_path"],
            "code": tst["code"]
        })
    return json.dumps(results)

tools = [
    Tool(name="ListJavaFiles", func=list_java_files, description="List Java files."),
    Tool(name="ExtractCodeInfo", func=extract_code_info, description="Extract class info."),
    Tool(name="GenerateJUnitTests", func=generate_junit_tests, description="Generate JUnit."),
    Tool(name="SaveJUnitTests", func=save_and_collect, description="Save & return code.")
]

# === Main Lambda Handler ===
def lambda_handler(event, context):
    try:
        body = event.get("body", None)
        if not body:
            return {
                "statusCode": 400,
                "body": json.dumps({"error": "Missing request body"})
            }

        if event.get("isBase64Encoded", False):
            raw = base64.b64decode(body)
        else:
            raw = body.encode('latin1')

        # Unzip uploaded Java project
        tmp = tempfile.mkdtemp()
        zip_path = os.path.join(tmp, "project.zip")
        with open(zip_path, "wb") as f:
            f.write(raw)
        extract_path = os.path.join(tmp, "unzipped")
        os.makedirs(extract_path, exist_ok=True)
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(extract_path)

        os.chdir(extract_path)

        agent = initialize_agent(
            tools=tools,
            llm=get_openai_client(),
            agent="zero-shot-react-description",
            verbose=False
        )
        result = agent.run("""
ListJavaFiles
Then ExtractCodeInfo
Then GenerateJUnitTests
Finally SaveJUnitTests
""")

        shutil.rmtree(tmp)

        return {
            "statusCode": 200,
            "body": json.dumps({
                "status": "success",
                "tests": json.loads(result)
            }),
            "headers": {"Content-Type": "application/json"},
            "isBase64Encoded": False
        }

    except Exception as e:
        logger.error("Unexpected error: %s", e, exc_info=True)
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)})
        }
