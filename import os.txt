import os
import json
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain.chat_models import ChatOpenAI

# === Configure your OpenAI client ===
def get_openai_client():
    return ChatOpenAI(temperature=0, model="gpt-4")

# === Load all Java files ===
def load_java_project_code(directory="./java_project"):
    code = []
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                with open(os.path.join(root, file), "r", encoding="utf-8") as f:
                    code.append(f.read())
    return "\n".join(code)

# === CHAIN 1: Analyze Java Project Structure ===
def analyze_java_codebase(combined_code: str):
    prompt = PromptTemplate(
        input_variables=["java_code"],
        template="""
You are a code analysis agent. Analyze the following Java codebase and extract its structure as JSON.

Respond with ONLY JSON like:
{{
  "com.example.service.CandidateService": {{
    "type": "Service",
    "methods": {{
      "getCandidate": {{
        "returns": "CandidateModel",
        "calls": ["candidateRepo.get"]
      }},
      "addCandidate": {{
        "returns": "CandidateModel",
        "calls": ["UUID.randomUUID().toString", "candidateRepo.put"]
      }}
    }},
    "depends_on": []
  }},
  "com.example.controller.CandidateController": {{
    "type": "Controller",
    "methods": {{
      "getCandidate": {{
        "returns": "ResponseEntity<CandidateModel>",
        "calls": ["candidateService.getCandidate"]
      }}
    }},
    "depends_on": ["CandidateService"]
  }}
}}

No markdown. No explanation. JSON only.

{java_code}
"""
    )

    llm = get_openai_client()
    chain = LLMChain(llm=llm, prompt=prompt)

    result = chain.run(java_code=combined_code)

    # Safely load JSON
    try:
        java_structure = json.loads(result)
    except json.JSONDecodeError:
        print("ERROR: Could not parse structure JSON")
        print(result)
        raise

    return java_structure

# === CHAIN 2: Generate JUnit Test Code ===
def generate_junit_tests(java_structure: dict):
    prompt = PromptTemplate(
        input_variables=["java_structure"],
        template="""
Given the following Java class structure, generate proper JUnit test classes for each Controller and ServiceImpl.

Return JSON in this format:
{{
  "file_name": "CandidateServiceImplTest.java",
  "package_path": "com/example/service",
  "code": "// Java code here"
}}

Generate proper test methods using Mockito and JUnit5. Include @Test, mocks, setup, and validation based on method names and dependencies.

{java_structure}
"""
    )

    llm = get_openai_client()
    chain = LLMChain(llm=llm, prompt=prompt)

    return chain.run(java_structure=json.dumps(java_structure))

# === Main Flow ===
if __name__ == "__main__":
    print("\n=== CHAIN 1: Analyzing Java Code ===")
    codebase = load_java_project_code()
    structure = analyze_java_codebase(codebase)
    print(json.dumps(structure, indent=2))  # Optional: for debug

    print("\n=== CHAIN 2: Generating JUnit Code ===")
    test_code_json = generate_junit_tests(structure)

    # Try parse output to structured format
    try:
        test_output = json.loads(test_code_json)
    except json.JSONDecodeError:
        print("ERROR: Could not parse generated test code")
        print(test_code_json)
        raise

    # Save files (optional)
    for test in test_output if isinstance(test_output, list) else [test_output]:
        file_path = os.path.join("generated_tests", test["package_path"], test["file_name"])
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(test["code"])
        print(f"âœ… Wrote {file_path}")
