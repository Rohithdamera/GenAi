import asyncio
import json
import nest_asyncio
from mcp import ClientSession
from mcp.client.sse import sse_client
from langchain.chat_models import AzureChatOpenAI
from langchain.agents import Tool, initialize_agent
from langchain.agents.agent_types import AgentType

nest_asyncio.apply()

# === OpenAI Client ===
def get_openai_client():
    return AzureChatOpenAI(
        azure_deployment="Fourth_Chatbot",
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        openai_api_version="2024-08-01-preview",
        openai_api_key="",  # <-- YOUR KEY HERE
        temperature=0.3,
        max_tokens=2000,
    )

# === SSE Tool Call Helpers ===
sse_url = "https://employee-mcp-v1-6b0n6.dw4w1g-2.gbr-e1.cloudhub.io/sse"

def sync_call_tool(name: str, params: dict):
    async def _call():
        async with sse_client(url=sse_url) as streams:
            async with ClientSession(*streams) as session:
                await session.initialize()
                return await session.call_tool(name, params)
    return asyncio.get_event_loop().run_until_complete(_call())

def fetch_tools_metadata():
    async def _fetch():
        async with sse_client(url=sse_url) as streams:
            async with ClientSession(*streams) as session:
                await session.initialize()
                return await session.list_tools()
    return asyncio.get_event_loop().run_until_complete(_fetch())

# === Create LangChain Tools ===
def get_tools():
    meta = fetch_tools_metadata()
    tools = []
    for t in getattr(meta, "tools", []):
        name = t.name
        req = t.inputSchema.get("required", []) if t.inputSchema else []
        desc = t.description or ""
        desc += f" Required fields: {req}"

        def make_fn(name=name, req=req):
            def fn(input_str: str) -> str:
                try:
                    params = json.loads(input_str) if input_str.strip() else {}
                except json.JSONDecodeError:
                    params = {}
                for k in req:
                    params.setdefault(k, "")
                try:
                    res = sync_call_tool(name, params)
                    return json.dumps(res, indent=2, default=str)
                except Exception as e:
                    return f"[ERROR] calling {name}: {e}"
            return fn

        tools.append(Tool(name=name, func=make_fn(), description=desc, return_direct=False))
    return tools

# === Custom ReAct Prompt to Enable Multi-hop, Fuzzy, Negative Logic ===
PREFIX = """
You are a powerful assistant with tools that can search through employees, projects, and assignments.
When a query might be fuzzy, indirect or negative (e.g. “not from X”, “no one in project Y”, misspellings), you should:

- Interpret typos or abbreviations (e.g. “banagalore” → “Bangalore”, “HYD” → “Hyderabad”).
- If the first tool returns no result, automatically chain to another tool (for example lookup employee by name, then lookup project assignments).
- Extract intermediate IDs and call detail tools as needed.
- If your final finding is “no results” you may still phrase it like: “There are currently no employees assigned to project X” (when applicable).

Finally, always return your answer in a **table format** showing key columns like GGID, Name, Role, Location, Project (if relevant), Experience, etc.

Explain reasoning concisely but focus on the final table. Do not mention JSON or internal schemas. Do not use emojis.
Begin now.
"""

# === Build and Run Agent ===
def build_agent():
    tools = get_tools()
    llm = get_openai_client()
    return initialize_agent(
        tools=tools,
        llm=llm,
        agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
        verbose=True,
        max_iterations=12,
        handle_parsing_errors=True,
        agent_kwargs={"prefix": PREFIX}
    )

if __name__ == "__main__":
    print("=== MCP Multi-hop, Fuzzy, Negative, Table Agent ===")
    agent = build_agent()
    while True:
        q = input("\nYour question: ").strip()
        if q.lower() in ("exit", "quit"):
            break
        try:
            resp = agent.invoke({"input": q})
            print("\nResult:\n")
            print(resp["output"])
        except Exception as e:
            print("Error:", e)
