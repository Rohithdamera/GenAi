import os
import json
import random
import string
import logging
from base64 import b64decode

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Mock OpenAI client
def mock_openai_client(model_instance_name):
    class MockClient:
        def invoke(self, messages):
            raml_content = messages[0]['content']
            endpoints = extract_endpoints_from_raml(raml_content)
            payloads = generate_payloads_for_endpoints(endpoints, raml_content)
            return type('obj', (object,), {'content': json.dumps(payloads)})
    return MockClient()

def extract_endpoints_from_raml(raml_content):
    endpoints = []
    lines = raml_content.split('\n')
    for line in lines:
        if line.strip().startswith('/'):
            endpoints.append(line.strip())
    return endpoints

def extract_fields_for_endpoint(endpoint, raml_content):
    fields = {}
    lines = raml_content.split('\n')
    capture = False
    for line in lines:
        if line.strip() == endpoint:
            capture = True
            continue
        if capture:
            if line.strip().startswith('/'):
                break  # Next endpoint found
            if ':' in line:
                key, val = line.strip().split(':', 1)
                fields[key.strip()] = val.strip()
    return fields

def generate_random_value(original_value):
    if original_value.isdigit():
        return random.randint(1000, 9999)
    elif original_value.lower() in ['true', 'false']:
        return random.choice([True, False])
    elif '-' in original_value and all(part.isdigit() for part in original_value.split('-') if part):
        return random.randint(10000, 99999)
    elif len(original_value) >= 8 and original_value.replace('-', '').isalnum():
        return ''.join(random.choices(string.ascii_letters + string.digits, k=10))
    return ''.join(random.choices(string.ascii_letters, k=8))

def generate_randomized_payload(field_template):
    return {k: generate_random_value(v) for k, v in field_template.items()}

def generate_payloads_for_endpoints(endpoints, raml_content):
    payloads = {}
    for endpoint in endpoints:
        fields = extract_fields_for_endpoint(endpoint, raml_content)
        payloads[endpoint] = [
            generate_randomized_payload(fields),
            generate_randomized_payload(fields)
        ]
    return payloads

def analyze_raml_with_openai(client, raml_content):
    try:
        prompt = (
            "You are a RAML test data generator.\n"
            "Each time you receive RAML content, you must:\n"
            "1. Identify all endpoints and associated fields.\n"
            "2. For each endpoint, generate two test payloads.\n"
            "3. Use **randomized values** for fields while keeping the field names and structure unchanged.\n"
            "4. Do not reuse or copy any actual values; only generate new random ones.\n\n"
            "Below is the RAML content:\n\n"
        )
        response = client.invoke([{"content": prompt + raml_content}])
        return response.content
    except Exception as e:
        logger.error(f"Error analyzing RAML with OpenAI: {e}")
        raise ValueError(f"Error analyzing RAML with OpenAI: {e}")

# AWS Lambda handler
def lambda_handler(event, context):
    logger.info("Lambda invoked.")
    try:
        if 'body' not in event or not event.get('isBase64Encoded', False):
            raise ValueError("RAML file content is missing or not base64-encoded.")

        raml_content = b64decode(event['body']).decode('utf-8')

        headers = event.get('headers', {})
        model_instance_name = (
            headers.get('model_instance_name') or
            headers.get('Model_Instance_Name') or
            os.environ.get('DEFAULT_MODEL_INSTANCE_NAME', 'default-model')
        )

        client = mock_openai_client(model_instance_name)
        result = analyze_raml_with_openai(client, raml_content)

        return {
            "statusCode": 200,
            "headers": {"Content-Type": "application/json"},
            "body": result
        }

    except Exception as e:
        logger.error(f"Execution error: {e}")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)})
        }
