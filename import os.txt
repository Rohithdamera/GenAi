import os
from pathlib import Path
from langchain.chat_models import AzureChatOpenAI
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
from langchain.schema.output_parser import StrOutputParser
from langchain.agents import initialize_agent, Tool
from langchain.memory import ConversationBufferMemory

# === Azure OpenAI client ===
def get_openai_client():
    return AzureChatOpenAI(
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        deployment_name="Fourth_Chatbot",
        openai_api_key="",  # Add your key
        openai_api_version="2024-08-01-preview",
        openai_api_type="azure",
        temperature=0.3,
        max_tokens=2000,
        model_kwargs={"top_p": 0.9, "frequency_penalty": 0.1, "presence_penalty": 0.0}
    )

project_path = r"C:\Users\rdamera\Downloads\OrderManagement 1\OrderManagement"

# === Agent 1: Java Source File Scanner ===
java_files = []
parsed_code_info = ""

def list_java_files(_: str) -> str:
    global java_files
    java_files = [
        os.path.join(root, f)
        for root, _, files in os.walk(project_path)
        for f in files if f.endswith(".java")
    ]
    if not java_files:
        return "[STOP] No Java files found."
    return f"Found {len(java_files)} Java files."

def extract_code_info(_: str) -> str:
    global java_files, parsed_code_info

    if not java_files:
        return "[SKIP] No Java files found to analyze."

    client = get_openai_client()

    # Prompt for parsing Java code to get structure
    analysis_prompt = PromptTemplate(
        input_variables=["java_source"],
        template="""
You are a static code analyzer for Java projects.

Given this Java file content, extract:
- class name
- class type (Controller, Service, Repository, etc.)
- its package path
- list of public methods with parameters
- which classes it depends on (calls)

Return structured JSON per file like:
{
  "class_name": "CandidateServiceImpl",
  "class_type": "Service",
  "package_path": "com.example.service",
  "dependencies": ["CandidateRepository"],
  "methods": ["public Candidate save(Candidate c)", "public List<Candidate> findAll()"]
}

Java File:
{java_source}
"""
    )

    chain = (
        lambda _: java_files
        | (lambda paths: [Path(p).read_text(encoding="utf-8") for p in paths])
        | (lambda contents: [{"java_source": c} for c in contents])
        | (lambda dicts: [LLMChain(llm=client, prompt=analysis_prompt).run(**d) for d in dicts])
    )

    parsed_code_info = chain(None)
    return "[SUCCESS] Java files analyzed and structure extracted."

# === Agent 2: JUnit Generator ===
generated_tests = []

def generate_junit_tests(_: str) -> str:
    global parsed_code_info, generated_tests

    if not parsed_code_info:
        return "[SKIP] No parsed code available."

    client = get_openai_client()

    junit_prompt = PromptTemplate(
        input_variables=["code_info"],
        template="""
You are a Java test generation expert.

Given this Java class info, generate a JUnit 5 test class using Mockito if needed. Test at least 80% of public methods.

Return response as JSON:
{
  "file_name": "<ClassName>Test.java",
  "package_path": "<same as source, like com/example/service>",
  "code": "<FULL VALID JAVA TEST CLASS CODE>"
}

Use standard test structure:
- @BeforeEach setup method
- @Test per method
- Mocks for dependencies
- Realistic method coverage

Class Info:
{code_info}
"""
    )

    # Generate JUnit tests for each parsed class
    generated_tests = [
        LLMChain(llm=client, prompt=junit_prompt).run(code_info=info)
        for info in parsed_code_info
    ]
    return "[SUCCESS] JUnit test classes generated."

# === MAIN ===
if __name__ == "__main__":
    print("\n=== Agent 1: Java Source Parser ===")
    memory1 = ConversationBufferMemory(memory_key="chat_history", return_messages=True)

    agent1 = initialize_agent(
        tools=[
            Tool(name="ListJavaFiles", func=list_java_files, description="List all Java source files."),
            Tool(name="ExtractCodeInfo", func=extract_code_info, description="Parse Java classes, methods, dependencies."),
        ],
        llm=get_openai_client(),
        agent_type="openai-functions",
        memory=memory1,
        verbose=True
    )

    agent1.invoke("List and extract class details from Java project source.")

    print("\n=== Agent 2: JUnit Code Generator ===")
    memory2 = ConversationBufferMemory(memory_key="chat_history", return_messages=True)

    agent2 = initialize_agent(
        tools=[
            Tool(name="GenerateJUnitTests", func=generate_junit_tests, description="Generate real JUnit test code files."),
        ],
        llm=get_openai_client(),
        agent_type="openai-functions",
        memory=memory2,
        verbose=True
    )

    agent2.invoke("Generate test classes for each Java source class found.")

    print("\n=== âœ… Final Output: Generated JUnit Test Classes ===")
    for output in generated_tests:
        print(output)
