import json
import base64
import logging
import random
import string
import os
from base64 import b64decode
from Crypto.Cipher import AES
import openai

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def unpad(data):
    padding_length = data[-1]
    return data[:-padding_length]

def decrypt(data, key):
    try:
        cipher = AES.new(b64decode(key), AES.MODE_ECB)
        decrypted_data = cipher.decrypt(b64decode(data))
        decrypted_data = unpad(decrypted_data)
        return decrypted_data.decode()
    except Exception as e:
        logger.error(f"Error during decryption: {e}")
        raise ValueError(f"Error during decryption: {e}")

def lambda_handler(event, context):
    logger.info("Lambda function invoked.")

    try:
        if 'body' not in event or not event.get('isBase64Encoded', False):
            raise ValueError("Missing or invalid file data in request.")

        if 'headers' not in event or 'model_instance_name' not in event['headers']:
            raise ValueError("Missing 'model_instance_name' in headers.")

        model_name = event['headers']['model_instance_name']

        # Step 1: Decode and extract RAML content
        content = base64.b64decode(event['body']).decode('utf-8')

        # Step 2: Extract embedded JSON starting at first `{`
        json_start = content.find('{')
        if json_start == -1:
            raise ValueError("No JSON content found in RAML file.")
        
        json_string = content[json_start:]
        original_data = json.loads(json_string)

        # Step 3: Create prompt dynamically
        prompt = (
            "You are a RAML test data generator. Based on the JSON structure below (from a RAML example), "
            "generate two different test payloads. Each field must retain its original data type (e.g., int, float, string), "
            "but the values must be changed to random and realistic examples. "
            "Only respond with a JSON object containing two payloads using the same structure:\n\n"
            f"{json.dumps(original_data, indent=2)}"
        )

        # Step 4: Use OpenAI (or Azure OpenAI) with decrypted credentials
        encrypted_api_key = os.environ['ENCRYPTED_API_KEY']
        encryption_key = os.environ['ENCRYPTION_KEY']
        api_key = decrypt(encrypted_api_key, encryption_key)

        openai.api_key = api_key

        response = openai.ChatCompletion.create(
            model=model_name,
            messages=[
                {"role": "system", "content": "You generate JSON test data for API testing."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=1000
        )

        ai_response = response['choices'][0]['message']['content']

        # Step 5: Try to parse response into JSON
        generated_payloads = json.loads(ai_response)

        return {
            "statusCode": 200,
            "headers": {"Content-Type": "application/json"},
            "body": json.dumps(generated_payloads)
        }

    except Exception as e:
        logger.error(f"Error in Lambda handler: {e}")
        return {
            "statusCode": 500,
            "headers": {"Content-Type": "application/json"},
            "body": json.dumps({"error": str(e)})
        }
