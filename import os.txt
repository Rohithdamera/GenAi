import json
import base64
import logging
import random
import string
from base64 import b64decode
from Crypto.Cipher import AES

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def unpad(data):
    return data[:-data[-1]]

def decrypt(data, key):
    try:
        cipher = AES.new(b64decode(key), AES.MODE_ECB)
        decrypted_data = cipher.decrypt(b64decode(data))
        return unpad(decrypted_data).decode()
    except Exception as e:
        logger.error(f"Decryption error: {e}")
        raise ValueError(f"Decryption error: {e}")

def detect_and_extract_json(content):
    try:
        return json.loads(content)
    except json.JSONDecodeError:
        json_start = content.find('{')
        if json_start == -1:
            raise ValueError("No JSON found.")
        return json.loads(content[json_start:])

def random_datetime():
    return f"{random.randint(1,28):02}/{random.randint(1,12):02}/2025 {random.randint(0,23):02}:{random.randint(0,59):02}:{random.randint(0,59):02}"

def random_uuid_like(value):
    parts = value.split('-')
    new_parts = []
    for part in parts:
        length = len(part)
        new_part = ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))
        new_parts.append(new_part)
    return '-'.join(new_parts)

def random_string(length):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def generate_id(length):
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))

def random_currency_code():
    return ''.join(random.choices(string.ascii_uppercase, k=3))

def looks_like_uuid(value):
    if not isinstance(value, str):
        return False
    if len(value) < 10 or len(value) > 50:
        return False
    if all(c in string.hexdigits + '-' for c in value.lower()):
        if value.count('-') >= 2:
            return True
    return False

def looks_like_date(value):
    if not isinstance(value, str):
        return False
    if ('/' in value or ':' in value) and not looks_like_uuid(value):
        return True
    return False

def smart_string_generator(field, value):
    if isinstance(value, str):
        if value.isdigit():
            return ''.join(random.choices(string.digits, k=len(value)))
        if len(value) == 3 and value.isalpha() and value.isupper():
            return random_currency_code()
        if looks_like_uuid(value):
            return random_uuid_like(value)
        if looks_like_date(value):
            return random_datetime()
        if any(c.isdigit() for c in value) and any(c.isalpha() for c in value):
            return ''.join(random.choices(string.ascii_uppercase + string.digits, k=len(value)))
        return random_string(len(value))
    return value

def generate_random_value_by_sample(field, value):
    if isinstance(value, int):
        return random.randint(1000, 999999)
    elif isinstance(value, float):
        return round(random.uniform(10.0, 99999.9), 2)
    elif isinstance(value, bool):
        return random.choice([True, False])
    elif isinstance(value, str):
        return smart_string_generator(field, value)
    return value

def generate_random_structure_with_fields(template, parent_key=""):
    if isinstance(template, dict):
        return {
            k: generate_random_structure_with_fields(v, k)
            for k, v in template.items()
        }
    elif isinstance(template, list):
        return [
            generate_random_structure_with_fields(v, parent_key)
            for v in template
        ]
    return generate_random_value_by_sample(parent_key, template)

def get_model_instance_name(event):
    return event.get('headers', {}).get('model_instance_name', 'chatbot_' + ''.join(random.choices(string.ascii_lowercase + string.digits, k=6)))

def get_count_from_headers(event):
    try:
        return max(1, int(event.get('headers', {}).get('count', '1')))
    except:
        return 1

def get_format_from_headers(event):
    return event.get('headers', {}).get('format', 'json').lower()

def build_dynamic_prompt(model_instance_name):
    return (
        f"You are a smart JSON data generator named '{model_instance_name}'. "
        "Generate diverse realistic JSON data based on the structure and data types. "
        "For string values that look numeric, generate new numeric strings. "
        "For ID or UUID-like strings (hex digits and dashes), generate similar random IDs maintaining format. "
        "For currency fields, generate random 3-letter uppercase currency codes. "
        "For actual date-like strings (containing '/' or ':' but NOT UUIDs), generate random dates. "
        "Preserve field names and structure, and ensure outputs are clean JSON with realistic data."
    )

def dict_to_xml(data, root_name="root"):
    def to_xml(value, tag):
        if isinstance(value, dict):
            return f"<{tag}>" + "".join(to_xml(v, k) for k, v in value.items()) + f"</{tag}>"
        elif isinstance(value, list):
            return "".join(to_xml(item, tag) for item in value)
        else:
            return f"<{tag}>{str(value)}</{tag}>"
    return f"<?xml version='1.0' encoding='UTF-8'?>\n<{root_name}>" + to_xml(data, "item") + f"</{root_name}>"

def lambda_handler(event, context):
    logger.info("Lambda triggered")

    try:
        body = event.get('body')
        if not body:
            raise ValueError("No body content received.")

        content = base64.b64decode(body).decode('utf-8') if event.get('isBase64Encoded', False) else body

        json_input = detect_and_extract_json(content)

        model_instance = get_model_instance_name(event)
        count = get_count_from_headers(event)
        format_type = get_format_from_headers(event)
        prompt = build_dynamic_prompt(model_instance)

        logger.info(f"Generating {count} datasets using model: {model_instance} with format: {format_type}")

        datasets = [generate_random_structure_with_fields(json_input) for _ in range(count)]

        if format_type == "xml":
            xml_body = "".join([dict_to_xml(ds, root_name=f"dataset_{i+1}") for i, ds in enumerate(datasets)])
            return {
                "statusCode": 200,
                "headers": {"Content-Type": "application/xml"},
                "body": xml_body
            }
        else:
            return {
                "statusCode": 200,
                "headers": {"Content-Type": "application/json"},
                "body": json.dumps({"datasets": datasets})
            }

    except Exception as e:
        logger.error(f"Error occurred: {e}")
        return {
            "statusCode": 500,
            "headers": {"Content-Type": "application/json"},
            "body": json.dumps({"error": str(e)})
        }
