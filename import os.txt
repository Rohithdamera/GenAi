import os
import json
import logging
import random
import string
from base64 import b64decode

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def random_value(value):
    if isinstance(value, str):
        return ''.join(random.choices(string.ascii_letters + string.digits, k=len(value)))
    elif isinstance(value, int):
        return random.randint(1000, 9999)
    elif isinstance(value, float):
        return round(random.uniform(1.0, 9999.9), 2)
    elif isinstance(value, list):
        return [random_value(v) for v in value]
    elif isinstance(value, dict):
        return {k: random_value(v) for k, v in value.items()}
    return value

def parse_raml_json_block(raml_content):
    try:
        lines = raml_content.splitlines()
        json_lines = []

        # Start from first line that looks like JSON
        in_json_block = False
        for line in lines:
            stripped = line.strip()
            if not in_json_block and (stripped.startswith('{') or stripped.startswith('[')):
                in_json_block = True
            if in_json_block:
                json_lines.append(line)

        json_text = "\n".join(json_lines)
        return json.loads(json_text)
    except Exception as e:
        logger.error(f"Error parsing JSON from RAML: {e}")
        raise ValueError("Invalid or missing JSON block in RAML content.")

def regenerate_payload_values(original_json):
    return random_value(original_json)

def lambda_handler(event, context):
    logger.info("Lambda invoked for single RAML file.")
    try:
        if 'body' not in event or not event.get('isBase64Encoded', False):
            raise ValueError("File content is missing or not base64-encoded.")

        # Decode base64 body to get the RAML file content
        raml_bytes = b64decode(event['body'])
        raml_content = raml_bytes.decode('utf-8', errors='ignore')

        # Extract the embedded JSON block
        original_payload = parse_raml_json_block(raml_content)

        # Generate new payload with same structure but randomized values
        randomized_payload = regenerate_payload_values(original_payload)

        return {
            "statusCode": 200,
            "headers": {"Content-Type": "application/json"},
            "body": json.dumps(randomized_payload, indent=2)
        }

    except Exception as e:
        logger.error(f"Error during execution: {e}")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)})
        }
