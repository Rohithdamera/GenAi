import os
import json
import re
from pathlib import Path
from typing import List, Dict

import gradio as gr
from langchain.prompts import PromptTemplate
from langchain_openai import AzureChatOpenAI
from langchain.callbacks import get_openai_callback

# === Azure OpenAI Client ===
def get_openai_client():
    return AzureChatOpenAI(
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        deployment_name="gpt-4_complex_conversions",
        openai_api_key="",  # put your key here or set env var
        openai_api_version="2024-08-01-preview",
        openai_api_type="azure",
        temperature=0.3,
        max_tokens=2000,
    )

llm = get_openai_client()

# === Step 1: Find Java Files Recursively ===
def find_java_files(path: str) -> List[Path]:
    base_path = Path(path)
    if not base_path.exists():
        raise FileNotFoundError(f"Path not found: {path}")
    return list(base_path.rglob("*.java"))

# === Step 2: Extract Metadata ===
def extract_class_metadata(java_paths: List[Path]) -> List[Dict]:
    prompt = PromptTemplate(
        input_variables=["source"],
        template="""
Analyze the following Java source code and return JSON with:
- class_name
- class_type: one of exactly ["Controller", "Service", "Repository", "Config", "Entity", "DTO", "Main"]
  Mapping:
    - @RestController/@Controller => "Controller"
    - @Service => "Service"
    - @Repository => "Repository"
    - @Entity/@Table => "Entity"
    - *DTO => "DTO"
    - main method => "Main"
- package_path
- methods: list of public method signatures (include parameter types & return type)
- uses_repository: true if this class has any field or constructor parameter whose type ends with 'Repository'

If class_type is "Entity" or "DTO", also include:
- entity_fields: list of {{"name": fieldName, "type": fieldType}}

⚠️ Always extract ALL fields from entities/DTOs.
Return compact valid JSON only.
Java Source:
{source}
"""
    )
    chain = prompt | llm

    parsed = []
    for file_path in java_paths:
        try:
            source = file_path.read_text(encoding="utf-8")
            response = chain.invoke({"source": source})
            data = json.loads(response.content.strip())
            parsed.append(data)
        except Exception as e:
            print(f"[WARN] Failed to parse {file_path}: {e}")
    return parsed

# === Step 3: Generate JUnit Tests ===
rules_text = """    
1. General    
- Always output valid compilable Java code.    
- One @Test per public method in the target class.    
- If a method works with an Entity/DTO, always create and fully populate that object using all fields from entity_map.    
- Use realistic dummy values (String, UUID, List<String>, LocalDateTime, int, boolean).    
- Never hardcode JSON payloads. Use ObjectMapper.    

2. Controller Tests    
- Use @WebMvcTest and MockMvc    
- @MockBean for services, @Autowired ObjectMapper    
- Populate DTOs in @BeforeEach    
- For POST/PUT: mock service + serialize with ObjectMapper    
- For GET by ID: mock service + validate jsonPath (and handle 404)    
- For GET all: mock service returning list, validate jsonPath    

3. Service Tests    
- No repository → plain instance, no mocks    
- With repository → @ExtendWith(MockitoExtension.class) + mock repo    
- Populate DTOs fully    
- Use assertThat assertions (never verify())    
- Test add/get/getAll methods properly    
"""

prompt = PromptTemplate(    
    input_variables=["class_name", "class_type", "package_path", "methods", "uses_repository", "entity_map"],    
    template="""    
Write a complete JUnit 5 test class for:    

Class Name: {class_name}    
Type: {class_type}    
Package: {package_path}    
Public Methods:    
{methods}    
uses_repository: {uses_repository}    
Available Entities (with fields):    
{entity_map}    

Follow these rules strictly:    

{rules_text}    
"""    
)

def generate_junit_tests_from_metadata(parsed_info: List[Dict]) -> List[Dict]:
    ALLOWED_TYPES = {"Controller", "Service"}
    entity_map = {
        item["class_name"]: item.get("entity_fields", [])
        for item in parsed_info
        if item.get("class_type") in {"Entity", "DTO"}
    }

    chain = prompt | llm
    test_classes = []
    for item in parsed_info:
        if item["class_type"] not in ALLOWED_TYPES:
            continue
        try:
            result = chain.invoke({
                "class_name": item["class_name"],
                "class_type": item["class_type"],
                "package_path": item["package_path"],
                "methods": "\n".join(item["methods"]),
                "uses_repository": str(item.get("uses_repository", False)).lower(),
                "entity_map": json.dumps(entity_map, indent=2),
                "rules_text": rules_text
            })
            test_classes.append({
                "file_name": f"{item['class_name']}Test.java",
                "package_path": item["package_path"],
                "code": result.content.strip()
            })
        except Exception as e:
            print(f"[WARN] Could not generate test for {item['class_name']}: {e}")
    return test_classes

# === Step 4: Save Files ===
def save_and_format_output(junit_tests: List[Dict]) -> str:
    output = ""
    for test in junit_tests:
        folder = Path("generated_tests") / test["package_path"].replace(".", "/")
        folder.mkdir(parents=True, exist_ok=True)
        file_path = folder / test["file_name"]
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(test["code"])
        output += f"\n===== {test['file_name']} =====\n{test['code']}\n===== End of {test['file_name']} =====\n"
    return output.strip()

# === Main ===
def process_java_project(prompt_text: str, history):
    try:
        path_match = re.search(r"([A-Za-z]:[\\/\w\-. ]+)", prompt_text)
        if not path_match:
            return "[ERROR] Please provide a valid Windows file path."

        project_path = path_match.group(1).strip()
        java_paths = find_java_files(project_path)
        if not java_paths:
            return "[INFO] No Java files found."

        with get_openai_callback() as cb:
            parsed_info = extract_class_metadata(java_paths)
            if not parsed_info:
                return "[INFO] No parsable Java classes found."

            test_classes = generate_junit_tests_from_metadata(parsed_info)
            if not test_classes:
                return "[INFO] No JUnit tests could be generated for allowed types."

            output_code = save_and_format_output(test_classes)

        return output_code
    except Exception as e:
        return f"[ERROR] {str(e)}"

chatbot_ui = gr.ChatInterface(
    fn=process_java_project,
    title="JUnit Test Generator",
    description="Give me a path to generate junit",
    theme="default"
)

if __name__ == "__main__":
    chatbot_ui.launch()
