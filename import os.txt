
import gradio as gr
import boto3
import re
from langchain_openai import AzureChatOpenAI

# --- AWS S3 Configuration ---
s3 = boto3.client(
    "s3",
    aws_access_key_id="AKIA6ODVATHCN52UKSRUO",
    aws_secret_access_key="N3+vw0XS4ZcdzqM0Zk6qflR7UbNy0ztQgdwWoiuEO",
    region_name="us-east-1"
)

S3_BUCKET = "oosif-files"
S3_KEY = "OSIF_Dependency_req.txt"

# --- Azure OpenAI Client ---
def get_openai_client():
    return AzureChatOpenAI(
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        deployment_name="gpt-4_complex_conversions",
        openai_api_key="",  # <-- put your real API key
        openai_api_version="2024-08-01-preview",
        openai_api_type="azure",
        temperature=0.3,
        max_tokens=2000,
    )

llm = get_openai_client()


# --- Load file from S3 ---
def load_s3_file():
    obj = s3.get_object(Bucket=S3_BUCKET, Key=S3_KEY)
    return obj["Body"].read().decode("utf-8")


# --- Identify connector name using AI ---
def identify_connector(query, content):
    """
    Ask Azure OpenAI to map the query to one of the available connectors in the file.
    """
    # Extract all available connector titles from file
    titles = re.findall(r"Title\s*:\s*(.+)", content, flags=re.IGNORECASE)
    connector_list = "\n".join([t.strip() for t in titles])

    prompt = f"""
You are given a list of connector titles from a file:
{connector_list}

User asked: "{query}"

Your task:
- Identify which connector title best matches the user's request.
- Only return the exact connector title string from the list above.
- If nothing matches, return "NOT_FOUND".
"""

    response = llm.invoke(prompt)
    connector = response.content.strip()
    return connector


# --- Extract the block for that connector ---
def extract_block(content, connector_title):
    """
    Extracts the block from file content starting with 'Title : connector_title'
    until the next 'Title :' or end of file.
    """
    if connector_title == "NOT_FOUND":
        return "Could not identify connector from your question."

    # Split into blocks
    blocks = re.split(r"(?=Title\s*:)", content, flags=re.IGNORECASE)
    for block in blocks:
        if not block.strip():
            continue
        if re.search(rf"Title\s*:\s*{re.escape(connector_title)}", block, flags=re.IGNORECASE):
            return block.strip()

    return f"Connector '{connector_title}' not found in file."


# --- Chatbot handler ---
def chatbot_response(message, history):
    try:
        content = load_s3_file()
        connector_title = identify_connector(message, content)
        result = extract_block(content, connector_title)
        return result
    except Exception as e:
        return f"Error: {str(e)}"


# --- Gradio Chat UI ---
chatbot_ui = gr.ChatInterface(
    fn=chatbot_response,
    title="OSIF Connector Lookup",
    description="Ask about connector properties (e.g., 'give me sales force connector properties')",
    theme="default"
)

if __name__ == "__main__":
    chatbot_ui.launch(debug=False)


---

ðŸ”‘ How It Works

1. Reads all connector titles from .txt in S3.


2. Uses Azure OpenAI to match userâ€™s query to the closest title.

"sales force connector" â†’ "sales-force-connector"

"common api library" â†’ "common-api-library"



3. Once the connector title is found, it extracts the entire block from the file.


4. Returns the raw block, no AI-generated properties.




---

ðŸ§ª Example Outputs

Q1: give me sales-force-connector properties
âž¡ Returns the full block starting with Title :sales-force-connector.

Q2: give me sales force connector
âž¡ Still maps â†’ sales-force-connector and returns only that block.

Q3: give me common api library properties
âž¡ Now it will correctly map to common-api-library and return its block.

Q4: give me common-api-library properties
âž¡ Same result as Q3.


---

âš¡ Would you like me to also make it tolerant of abbreviations (e.g., "sfdc" â†’ sales-force-connector automatically)?

