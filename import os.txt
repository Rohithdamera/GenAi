import os
import logging
import json
import re
from base64 import b64decode
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from langchain_community.chat_models import AzureChatOpenAI
from langchain.schema import HumanMessage
import tempfile
import openpyxl
from openpyxl.utils import column_index_from_string

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()

# AES Decryption
def decrypt(data, key):
    cipher = AES.new(b64decode(key), AES.MODE_ECB)
    decrypted_data = cipher.decrypt(b64decode(data))
    decrypted_data = unpad(decrypted_data, AES.block_size)
    return decrypted_data.decode()

# Azure OpenAI Client
def get_openai_client(model_instance_name):
    aes_key_base64 = os.environ['AES_KEY']
    encrypted_api_base = os.environ['ENCRYPTED_API_BASE']
    encrypted_api_key = os.environ['ENCRYPTED_API_KEY']
    api_version = os.environ['AZURE_API_VERSION']

    decrypted_api_base = decrypt(encrypted_api_base, aes_key_base64)
    decrypted_api_key = decrypt(encrypted_api_key, aes_key_base64)

    if not decrypted_api_base.endswith('/'):
        decrypted_api_base += '/'

    return AzureChatOpenAI(
        deployment_name=model_instance_name,
        openai_api_base=decrypted_api_base,
        openai_api_key=decrypted_api_key,
        openai_api_version=api_version,
        temperature=0.4,
        max_tokens=4096
    )

def col_letter_to_index(letter):
    return column_index_from_string(letter.upper()) - 1

# Extract required metadata from prompt
def extract_metadata(prompt):
    sheet_match = re.search(r'sheet\s+name\s+is[:\-]?\s*([^\n\r]+)', prompt, re.IGNORECASE)
    source_match = re.search(r'source\s+column\s*[:\-]?\s*([A-Z])', prompt, re.IGNORECASE)
    target_match = re.search(r'target\s+column\s*[:\-]?\s*([A-Z])', prompt, re.IGNORECASE)
    logic_match = re.search(r'business\s+logic\s+column\s*[:\-]?\s*([A-Z])', prompt, re.IGNORECASE)

    if not (sheet_match and source_match and target_match and logic_match):
        raise ValueError("Prompt must include sheet name, source column, target column, and business logic column.")

    return {
        "sheet_name": sheet_match.group(1).strip(),
        "source_col": col_letter_to_index(source_match.group(1)),
        "target_col": col_letter_to_index(target_match.group(1)),
        "logic_col": col_letter_to_index(logic_match.group(1)),
    }

def extract_excel_data(file_path, sheet_name, source_col, logic_col, target_col):
    try:
        wb = openpyxl.load_workbook(file_path, data_only=True)
        sheet = wb[sheet_name]
        data = []
        for row in sheet.iter_rows(min_row=2, values_only=True):
            source = row[source_col]
            logic = row[logic_col]
            target = row[target_col]
            if source and target:
                data.append({
                    "source": source,
                    "logic": logic or "",
                    "target": target
                })
        return data
    except Exception as e:
        logger.error(f"Failed to extract Excel data: {e}")
        return []

def lambda_handler(event, context):
    try:
        headers = event.get("headers", {}) or {}
        model_instance = headers.get("model_instance_name", "")
        query = event.get("queryStringParameters", {}) or {}

        instruction = query.get("instruction", "")
        prompt_text = query.get("prompt", "")

        if not instruction or not prompt_text:
            raise ValueError("Both 'instruction' and 'prompt' query parameters are required.")

        if not event.get("isBase64Encoded", False):
            raise ValueError("Expected base64-encoded binary file.")

        body_b64 = event.get("body", "")
        if not body_b64:
            raise ValueError("No file content found in the request body.")

        body = b64decode(body_b64)
        with tempfile.NamedTemporaryFile(delete=False, suffix=".xlsx") as temp_file:
            temp_file.write(body)
            temp_file_path = temp_file.name

        metadata = extract_metadata(prompt_text)
        extracted_data = extract_excel_data(
            temp_file_path,
            metadata["sheet_name"],
            metadata["source_col"],
            metadata["logic_col"],
            metadata["target_col"]
        )

        formatted_rows = "\n".join(
            f"- Source: {row['source']}, Target: {row['target']}, Logic: {row['logic']}" for row in extracted_data
        )

        full_prompt = f"{instruction.strip()}\n\n{prompt_text.strip()}\n\nExcel Extracted Data:\n{formatted_rows}"

        client = get_openai_client(model_instance)
        response = client.invoke([
            HumanMessage(content=full_prompt),
            HumanMessage(content="Generate the test data based on the uploaded Excel.")
        ])

        return {
            "statusCode": 200,
            "headers": {"Content-Type": "text/plain"},
            "body": response.content.strip()
        }

    except Exception as e:
        logger.error(f"Error: {e}")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)})
        }
