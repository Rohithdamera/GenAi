import time, uuid, json, nest_asyncio, pandas as pd, asyncio
from mcp import ClientSession
from mcp.client.sse import sse_client
from langchain.chat_models import AzureChatOpenAI
from langchain.agents import Tool, initialize_agent
from langchain.agents.agent_types import AgentType

nest_asyncio.apply()

# ——— Session Memory with TTL ———
chat_sessions = {}
SESSION_TTL = 30 * 60

def create_session():
    cid = str(uuid.uuid4())
    chat_sessions[cid] = {"start": time.time(), "messages": []}
    return cid

def add_msg(cid, role, msg):
    if cid in chat_sessions:
        chat_sessions[cid]["messages"].append({"role": role, "msg": msg})

def get_history(cid):
    return chat_sessions.get(cid, {}).get("messages", [])

def cleanup_sessions():
    now = time.time()
    expired = [cid for cid, ses in chat_sessions.items() if now - ses["start"] > SESSION_TTL]
    for cid in expired:
        del chat_sessions[cid]

# ——— LLM Setup ———
def get_openai_client():
    return AzureChatOpenAI(
        azure_deployment="Fourth_Chatbot",
        azure_endpoint="https://testopenaiassets.openai.azure.com",
        openai_api_version="2024-08-01-preview",
        azure_openai_api_key="",  # Insert key securely
        temperature=0.3,
    )

# ——— Tool Helpers ———
sse_url = "https://mcp-server-sse-cg-employees-sandbox-6b0n6.dw4w1g-2.gbr-e1.cloudhub.io/sse"

def sync_call(tool_name, params):
    async def call():
        async with sse_client(url=sse_url) as streams:
            async with ClientSession(*streams) as session:
                await session.initialize()
                result = await session.call_tool(tool_name, params)
                return parse_tool_result(result)
    return asyncio.get_event_loop().run_until_complete(call())

def parse_tool_result(result):
    """Ensure response is safely JSON serializable"""
    if hasattr(result, "content"):
        try:
            if isinstance(result.content, list):
                return [c.text for c in result.content if hasattr(c, "text")]
            elif isinstance(result.content, str):
                return result.content
            elif hasattr(result.content, "text"):
                return result.content.text
        except Exception as e:
            return f"[Tool Result Error] {str(e)}"
    return str(result)

def fetch_tools():
    async def call():
        async with sse_client(url=sse_url) as streams:
            async with ClientSession(*streams) as session:
                await session.initialize()
                return await session.list_tools()
    return asyncio.get_event_loop().run_until_complete(call())

def build_tools():
    raw = fetch_tools()
    tools = []

    for t in getattr(raw, "tools", []):
        name = t.name
        schema = t.inputSchema or {}
        required = schema.get("required", [])
        props = schema.get("properties", {})

        def make_fn(tool_name=name, req=required):
            def fn(input_str: str) -> str:
                try:
                    parsed = json.loads(input_str or "{}")
                    for k in req:
                        parsed.setdefault(k, "")
                    result = sync_call(tool_name, parsed)
                    return json.dumps(result, indent=2, default=str)
                except Exception as e:
                    return f"[ERROR] {tool_name}: {str(e)}"
            return fn

        tools.append(Tool(
            name=name,
            func=make_fn(),
            description=f"{t.description} | required: {required}",
            return_direct=False
        ))
    return tools

# ——— Output Formatting ———
def to_table(text: str):
    try:
        data = json.loads(text)
        if isinstance(data, list):
            df = pd.DataFrame(data)
        elif isinstance(data, dict):
            df = pd.DataFrame([data])
        else:
            return str(data)
        return df.to_string(index=False)
    except Exception:
        return text

# ——— Agent Prompt ———
PROMPT = """
You are a smart assistant for employee data. Use the tools with proper schema.
Always format your CreateEmployee and other tool inputs to match required fields and data types.
If an operation fails, analyze why and correct it. Output everything in clean tabular format.
"""

# ——— Agent Builder ———
def build_agent():
    return initialize_agent(
        tools=build_tools(),
        llm=get_openai_client(),
        agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
        verbose=True,
        max_iterations=5,
        handle_parsing_errors=True,
        agent_kwargs={"prefix": PROMPT}
    )

# ——— CLI or Lambda Entry ———
if __name__ == "__main__":
    cid = create_session()
    agent = build_agent()
    print(f"[Session ID: {cid}]")

    while True:
        cleanup_sessions()
        q = input("> ").strip()
        if q.lower() in ("exit", "quit"):
            print("Session ended.")
            break

        if "chat history" in q.lower():
            print("\n[Chat History]")
            for m in get_history(cid):
                print(f"{m['role'].capitalize()}: {m['msg']}")
            continue

        add_msg(cid, "user", q)
        try:
            result = agent.invoke({"input": q})
            output = result["output"]
            print("\nAnswer:\n")
            print(to_table(output))
            add_msg(cid, "assistant", output)
        except Exception as e:
            print("[Error]", str(e))
