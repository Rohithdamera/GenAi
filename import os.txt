import base64
import json
import xml.etree.ElementTree as ET
import os
import logging
from io import BytesIO
from docx import Document
from Crypto.Cipher import AES
import random
import string

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def decrypt_password(enc_password_b64, key):
    try:
        enc_password = base64.b64decode(enc_password_b64)
        cipher = AES.new(key.encode('utf-8'), AES.MODE_ECB)
        decrypted = cipher.decrypt(enc_password)
        return decrypted.decode('utf-8').strip()
    except Exception as e:
        logger.error(f"Decryption failed: {str(e)}")
        return ""

def generate_raml(endpoint_name, request_format, response_format, table_data, params):
    endpoint_slug = endpoint_name.strip().lower().replace(" ", "-")

    request_type_name = f"{endpoint_slug}-request"
    response_type_name = f"{endpoint_slug}-response"
    error_type_name = "error-response"

    main_raml = f"""#%RAML 1.0
title: {endpoint_name} API
version: 1.0
baseUri: http://api.example.com/{{version}}
mediaType: application/{request_format}

types:
  {request_type_name}: !include types/{request_type_name}.raml
  {response_type_name}: !include types/{response_type_name}.raml
  {error_type_name}: !include types/{error_type_name}.raml

/{endpoint_slug}:
  post:
    description: {endpoint_name}
    body:
      application/{request_format}:
        type: {request_type_name}
        example: !include examples/{request_type_name}.json
    responses:
      200:
        body:
          application/{response_format}:
            type: {response_type_name}
            example: !include examples/{response_type_name}.json
      400:
        body:
          application/json:
            type: {error_type_name}
            example: !include examples/{error_type_name}.json
"""
    def get_data_type(value):
        value = value.lower()
        if "string" in value:
            return "string"
        elif "int" in value:
            return "integer"
        elif "date" in value:
            return "datetime"
        elif "boolean" in value:
            return "boolean"
        return "string"

    def generate_fragment(fields):
        fragment = "#%RAML 1.0 DataType\n"
        fragment += "type: object\nproperties:\n"
        for field in fields:
            name = field.get(params['apiFields'], '').strip()
            dtype = get_data_type(field.get(params['apiFieldType'], ''))
            required = field.get(params['apiRequired'], '').strip().lower() == 'yes'
            nullable = field.get(params['apiNullable'], '').strip().lower() == 'yes'
            max_len = "  maxLength: 50\n" if dtype == 'string' else ""
            required_str = "true" if required else "false"
            nullable_str = "  nullable: true\n" if nullable else ""

            fragment += f"  {name}:\n"
            fragment += f"    type: {dtype}\n"
            fragment += f"{max_len}"
            fragment += f"    required: {required_str}\n"
            fragment += f"{nullable_str}"
        return fragment

    redeem_req_fragment = generate_fragment(table_data)
    redeem_resp_fragment = generate_fragment(table_data)

    error_fragment = """#%RAML 1.0 DataType
type: object
properties:
  errorCode:
    type: integer
    required: true
  errorMessage:
    type: string
    required: true
"""

    redeem_req_example = json.dumps({field[params['apiFields']]: "value" for field in table_data}, indent=2)
    redeem_resp_example = json.dumps({field[params['apiFields']]: "response" for field in table_data}, indent=2)
    error_example = json.dumps({
        "errorCode": 400,
        "errorMessage": "Invalid request"
    }, indent=2)

    return {
        "main_raml": main_raml,
        f"types/{request_type_name}.raml": redeem_req_fragment,
        f"types/{response_type_name}.raml": redeem_resp_fragment,
        f"types/{error_type_name}.raml": error_fragment,
        f"examples/{request_type_name}.json": redeem_req_example,
        f"examples/{response_type_name}.json": redeem_resp_example,
        f"examples/{error_type_name}.json": error_example
    }

def parse_docx_fields(docx_content):
    document = Document(BytesIO(docx_content))
    table_data = []
    for table in document.tables:
        keys = [cell.text.strip() for cell in table.rows[0].cells]
        for row in table.rows[1:]:
            row_data = {}
            for idx, cell in enumerate(row.cells):
                if idx < len(keys):
                    row_data[keys[idx]] = cell.text.strip()
            table_data.append(row_data)
    return table_data

def lambda_handler(event, context):
    try:
        headers = event.get('headers', {})
        model_instance_name = headers.get('model_instance_name', 'default_model')
        count = int(headers.get('count', '1'))

        query_params = event.get("queryStringParameters", {}) or {}

        body = event.get("body", "")
        if event.get("isBase64Encoded", False):
            body = base64.b64decode(body)

        table_data = parse_docx_fields(body)

        endpoint_name = query_params.get("endpointName", "My API")
        request_payload = query_params.get("requestPayload", "json")
        response_payload = query_params.get("responsePayload", "json")

        expected_keys = ['apiFields', 'apiFieldType', 'apiRequired', 'apiNullable', 'apiExample', 'apiPattern']
        missing_keys = [key for key in expected_keys if key not in query_params]
        if missing_keys:
            return {
                "statusCode": 400,
                "body": f"Missing keys in query params: {', '.join(missing_keys)}"
            }

        raml_outputs = generate_raml(endpoint_name, request_payload, response_payload, table_data, query_params)

        return {
            "statusCode": 200,
            "body": json.dumps({
                "message": "RAML generated successfully",
                "files": raml_outputs
            }),
            "headers": {"Content-Type": "application/json"}
        }

    except Exception as e:
        logger.error(f"Error occurred: {str(e)}")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)})
        }
